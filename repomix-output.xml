This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
api/
  cachepb/
    cache_grpc.pb.go
    cache.pb.go
    cache.proto
bin/
  client
  server
cmd/
  client/
    main.go
  server/
    main.go
config/
  config.go
internal/
  byteview/
    byteview_test.go
    byteview.go
  cache/
    cache_test.go
    cache.go
  consistenthash/
    consistenthash_test.go
    consistenthash.go
  core/
    fifo/
      fifo_test.go
      fifo.go
    lfu/
      lfu_test.go
      lfu.go
    lru/
      lru_test.go
      lru.go
    policy/
      types.go
  discovery/
    discovery.go
    register.go
  group/
    group_test.go
    group.go
    peers.go
  server/
    grpc.go
    http.go
    server_test.go
  singleflight/
    singleflight_test.go
    singleflight.go
scripts/
  run.sh
test/
  benchmark_test.go
.cspell.json
config.json
go.mod
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="api/cachepb/cache_grpc.pb.go">
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: api/cachepb/cache.proto
// cSpell:ignore protoc
// cSpell:ignore cachepb

package cachepb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GroupCache_Get_FullMethodName = "/cachepb.GroupCache/Get"
)

// GroupCacheClient is the client API for GroupCache service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// GroupCache å®šä¹‰åˆ†å¸ƒå¼ç¼“å­˜çš„ RPC æœåŠ¡
type GroupCacheClient interface {
	// Get æ–¹æ³•ï¼šæ ¹æ® Group å’Œ Key è·å–ç¼“å­˜å€¼
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
}

type groupCacheClient struct {
	cc grpc.ClientConnInterface
}

func NewGroupCacheClient(cc grpc.ClientConnInterface) GroupCacheClient {
	return &groupCacheClient{cc}
}

func (c *groupCacheClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, GroupCache_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroupCacheServer is the server API for GroupCache service.
// All implementations must embed UnimplementedGroupCacheServer
// for forward compatibility.
//
// GroupCache å®šä¹‰åˆ†å¸ƒå¼ç¼“å­˜çš„ RPC æœåŠ¡
type GroupCacheServer interface {
	// Get æ–¹æ³•ï¼šæ ¹æ® Group å’Œ Key è·å–ç¼“å­˜å€¼
	Get(context.Context, *GetRequest) (*GetResponse, error)
	mustEmbedUnimplementedGroupCacheServer()
}

// UnimplementedGroupCacheServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGroupCacheServer struct{}

func (UnimplementedGroupCacheServer) Get(context.Context, *GetRequest) (*GetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedGroupCacheServer) mustEmbedUnimplementedGroupCacheServer() {}
func (UnimplementedGroupCacheServer) testEmbeddedByValue()                    {}

// UnsafeGroupCacheServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroupCacheServer will
// result in compilation errors.
type UnsafeGroupCacheServer interface {
	mustEmbedUnimplementedGroupCacheServer()
}

func RegisterGroupCacheServer(s grpc.ServiceRegistrar, srv GroupCacheServer) {
	// If the following call panics, it indicates UnimplementedGroupCacheServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GroupCache_ServiceDesc, srv)
}

func _GroupCache_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupCacheServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupCache_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupCacheServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GroupCache_ServiceDesc is the grpc.ServiceDesc for GroupCache service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GroupCache_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cachepb.GroupCache",
	HandlerType: (*GroupCacheServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _GroupCache_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/cachepb/cache.proto",
}
</file>

<file path="api/cachepb/cache.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: api/cachepb/cache.proto
// cSpell:ignore cachepb

package cachepb

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// GetRequest å®šä¹‰ Get æ–¹æ³•çš„è¯·æ±‚å‚æ•°
type GetRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// group æ˜¯ç¼“å­˜çš„å‘½åç©ºé—´ï¼Œä¾‹å¦‚ "scores", "users"
	Group string `protobuf:"bytes,1,opt,name=group,proto3" json:"group,omitempty"` // // å­—æ®µç¼–å· 1
	// key æ˜¯å…·ä½“çš„ç¼“å­˜é”®
	Key           string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRequest) Reset() {
	*x = GetRequest{}
	mi := &file_api_cachepb_cache_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRequest) ProtoMessage() {}

func (x *GetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_cachepb_cache_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) {
	return file_api_cachepb_cache_proto_rawDescGZIP(), []int{0}
}

func (x *GetRequest) GetGroup() string {
	if x != nil {
		return x.Group
	}
	return ""
}

func (x *GetRequest) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

// GetResponse å®šä¹‰ Get æ–¹æ³•çš„å“åº”
type GetResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// value æ˜¯ç¼“å­˜çš„å€¼ï¼Œä½¿ç”¨ bytes ç±»å‹ä»¥æ”¯æŒä»»æ„äºŒè¿›åˆ¶æ•°æ®
	Value         []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResponse) Reset() {
	*x = GetResponse{}
	mi := &file_api_cachepb_cache_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse) ProtoMessage() {}

func (x *GetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_cachepb_cache_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) {
	return file_api_cachepb_cache_proto_rawDescGZIP(), []int{1}
}

func (x *GetResponse) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

var File_api_cachepb_cache_proto protoreflect.FileDescriptor

const file_api_cachepb_cache_proto_rawDesc = "" +
	"\n" +
	"\x17api/cachepb/cache.proto\x12\acachepb\"4\n" +
	"\n" +
	"GetRequest\x12\x14\n" +
	"\x05group\x18\x01 \x01(\tR\x05group\x12\x10\n" +
	"\x03key\x18\x02 \x01(\tR\x03key\"#\n" +
	"\vGetResponse\x12\x14\n" +
	"\x05value\x18\x01 \x01(\fR\x05value2>\n" +
	"\n" +
	"GroupCache\x120\n" +
	"\x03Get\x12\x13.cachepb.GetRequest\x1a\x14.cachepb.GetResponseB&Z$DistributedCache/api/cachepb;cachepbb\x06proto3"

var (
	file_api_cachepb_cache_proto_rawDescOnce sync.Once
	file_api_cachepb_cache_proto_rawDescData []byte
)

func file_api_cachepb_cache_proto_rawDescGZIP() []byte {
	file_api_cachepb_cache_proto_rawDescOnce.Do(func() {
		file_api_cachepb_cache_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_cachepb_cache_proto_rawDesc), len(file_api_cachepb_cache_proto_rawDesc)))
	})
	return file_api_cachepb_cache_proto_rawDescData
}

var file_api_cachepb_cache_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_api_cachepb_cache_proto_goTypes = []any{
	(*GetRequest)(nil),  // 0: cachepb.GetRequest
	(*GetResponse)(nil), // 1: cachepb.GetResponse
}
var file_api_cachepb_cache_proto_depIdxs = []int32{
	0, // 0: cachepb.GroupCache.Get:input_type -> cachepb.GetRequest
	1, // 1: cachepb.GroupCache.Get:output_type -> cachepb.GetResponse
	1, // [1:2] is the sub-list for method output_type
	0, // [0:1] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_api_cachepb_cache_proto_init() }
func file_api_cachepb_cache_proto_init() {
	if File_api_cachepb_cache_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_cachepb_cache_proto_rawDesc), len(file_api_cachepb_cache_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_api_cachepb_cache_proto_goTypes,
		DependencyIndexes: file_api_cachepb_cache_proto_depIdxs,
		MessageInfos:      file_api_cachepb_cache_proto_msgTypes,
	}.Build()
	File_api_cachepb_cache_proto = out.File
	file_api_cachepb_cache_proto_goTypes = nil
	file_api_cachepb_cache_proto_depIdxs = nil
}
</file>

<file path="api/cachepb/cache.proto">
// cSpell:ignore cachepb
syntax = "proto3"; // ä½¿ç”¨ proto3 è¯­æ³•ç‰ˆæœ¬

package cachepb;

// Go åŒ…è·¯å¾„
//  Go ä»£ç ç”Ÿæˆé€‰é¡¹ï¼šç”Ÿæˆè·¯å¾„ä¸º DistributedCache/api/cachepbï¼ŒåŒ…åä¸º cachepb
option go_package = "DistributedCache/api/cachepb;cachepb";

// GetRequest å®šä¹‰ Get æ–¹æ³•çš„è¯·æ±‚å‚æ•°
message GetRequest {
  // group æ˜¯ç¼“å­˜çš„å‘½åç©ºé—´ï¼Œä¾‹å¦‚ "scores", "users"
  string group = 1;  // // å­—æ®µç¼–å· 1
  // key æ˜¯å…·ä½“çš„ç¼“å­˜é”®
  string key = 2;
}


// GetResponse å®šä¹‰ Get æ–¹æ³•çš„å“åº”
message GetResponse {
  // value æ˜¯ç¼“å­˜çš„å€¼ï¼Œä½¿ç”¨ bytes ç±»å‹ä»¥æ”¯æŒä»»æ„äºŒè¿›åˆ¶æ•°æ®
  bytes value = 1;
}

// GroupCache å®šä¹‰åˆ†å¸ƒå¼ç¼“å­˜çš„ RPC æœåŠ¡
service GroupCache {
  // Get æ–¹æ³•ï¼šæ ¹æ® Group å’Œ Key è·å–ç¼“å­˜å€¼
  rpc Get(GetRequest) returns (GetResponse);
}

// å½“ protobuf åºåˆ—åŒ–æ•°æ®æ—¶ï¼šä¸å­˜å‚¨å­—æ®µå "group"ã€"key";åªå­˜å‚¨å­—æ®µç¼–å· 1ã€"groupçš„å€¼"ã€2ã€"keyçš„å€¼"
</file>

<file path="cmd/client/main.go">
package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"time"

	pb "DistributedCache/api/cachepb"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

func main() {
	var (
		serverAddr string
		groupName  string
		key        string
	)
	flag.StringVar(&serverAddr, "server", "localhost:8001", "Connect to which cache server node")
	flag.StringVar(&groupName, "group", "scores", "Cache group name")
	flag.StringVar(&key, "key", "Tom", "Key to fetch")
	flag.Parse()

	// 1. è¿æ¥åˆ° gRPC æœåŠ¡å™¨
	// ä½¿ç”¨ä¸å®‰å…¨çš„è¿æ¥ï¼ˆæ—  TLSï¼‰æ–¹ä¾¿æµ‹è¯•
	conn, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("Did not connect: %v", err)
	}
	defer conn.Close() // å‡½æ•°returnæ—¶ä¼šå…³é—­è¿æ¥ï¼Œç„¶åå››æ¬¡æ¡æ‰‹Fin

	client := pb.NewGroupCacheClient(conn)

	// 2. æ„é€ è¯·æ±‚
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel() // ç¡®ä¿å‡½æ•°é€€å‡ºæ—¶è°ƒç”¨ cancel æ¸…ç†èµ„æº

	req := &pb.GetRequest{
		Group: groupName,
		Key:   key,
	}

	// 3. å‘èµ·è°ƒç”¨
	log.Printf("Requesting Key [%s] from Group [%s] via Node [%s]...", key, groupName, serverAddr)
	start := time.Now()
	resp, err := client.Get(ctx, req)
	elapsed := time.Since(start)

	if err != nil {
		log.Fatalf("Could not get cache: %v", err)
	}

	// 4. è¾“å‡ºç»“æœ
	fmt.Printf("--------------------------------\n")
	fmt.Printf("Result: %s\n", string(resp.GetValue()))
	fmt.Printf("Time:   %v\n", elapsed)
	fmt.Printf("--------------------------------\n")
}
</file>

<file path="config/config.go">
package config

import (
	"encoding/json"
	"os"
)

// ServerConfig å®šä¹‰æœåŠ¡ç«¯é…ç½®ç»“æ„
// é‡‡ç”¨æ‰å¹³åŒ–ç»“æ„ï¼Œç›´æ¥å¯¹åº” main.go ä¸­çš„ cfg.Addr, cfg.EtcdAddrs ç­‰å­—æ®µè°ƒç”¨
type ServerConfig struct {
	Addr        string   `json:"addr"`         // æœ¬èŠ‚ç‚¹ç›‘å¬åœ°å€ï¼Œä¾‹å¦‚ "localhost:8001"
	EtcdAddrs   []string `json:"etcd_addrs"`   // Etcd é›†ç¾¤åœ°å€åˆ—è¡¨
	CacheSize   int64    `json:"cache_size"`   // æœ€å¤§ç¼“å­˜å¤§å° (bytes)
	CachePolicy string   `json:"cache_policy"` // æ·˜æ±°ç­–ç•¥: "lru", "lfu", "fifo"
	ServiceName string   `json:"service_name"` // æœåŠ¡æ³¨å†Œå‰ç¼€ï¼Œä¾‹å¦‚ "distributed-cache/nodes"
}

// DefaultConfig è¿”å›é»˜è®¤é…ç½®
// å½“é…ç½®æ–‡ä»¶ä¸å­˜åœ¨æˆ–åŠ è½½å¤±è´¥æ—¶ï¼Œmain.go ä¼šä½¿ç”¨æ­¤é»˜è®¤å€¼
func DefaultConfig() *ServerConfig {
	return &ServerConfig{
		Addr:        "localhost:8001",
		EtcdAddrs:   []string{"localhost:2379"},
		CacheSize:   2 << 20, // é»˜è®¤ 2MB
		CachePolicy: "lru",
		ServiceName: "distributed-cache/nodes",
	}
}

// LoadConfig ä»æŒ‡å®šè·¯å¾„åŠ è½½ JSON é…ç½®æ–‡ä»¶
func LoadConfig(path string) (*ServerConfig, error) {
	file, err := os.Open(path)
	if err != nil {
		// è¿”å›é”™è¯¯ï¼Œç”±è°ƒç”¨æ–¹(main.go)å†³å®šæ˜¯å¦ä½¿ç”¨é»˜è®¤é…ç½®
		return nil, err
	}
	defer file.Close()

	cfg := &ServerConfig{}
	decoder := json.NewDecoder(file)
	if err := decoder.Decode(cfg); err != nil {
		return nil, err
	}
	return cfg, nil
}
</file>

<file path="internal/byteview/byteview_test.go">
package byteview

import "testing"

func TestByteViewCopy(t *testing.T) {
	data := []byte("hello")
	bv := New(data)

	data[0] = 'X'
	if string(bv.ByteSlice()) != "hello" {
		t.Fatalf("ByteView modified unexpectedly: %s", bv.ByteSlice())
	}
}

func TestByteViewLen(t *testing.T) {
	bv := New([]byte("12345"))
	if bv.Len() != 5 {
		t.Fatalf("unexpected Len(): %d", bv.Len())
	}
}
</file>

<file path="internal/byteview/byteview.go">
package byteview

type Byteview struct {
	b []byte
}

// New åˆ›å»ºä¸€ä¸ª ByteView
func New(b []byte) Byteview {
	c := make([]byte, len(b))
	copy(c, b)
	return Byteview{b: c}
}

func (v Byteview) Len() int {
	return len(v.b)
}

func (v Byteview) ByteSlice() []byte {
	c := make([]byte, len(v.b))
	copy(c, v.b)
	return c
}

func (v Byteview) String() string {
	return string(v.b)
}
</file>

<file path="internal/consistenthash/consistenthash_test.go">
package consistenthash

import (
	"strconv"
	"testing"
)

func TestHashing(t *testing.T) {
	// è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°ï¼Œæ–¹ä¾¿æµ‹è¯•ç»“æœå¯é¢„æµ‹
	// è¿™é‡Œç®€å•çš„å°†æ•°å­—å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°ä½œä¸ºå“ˆå¸Œå€¼
	hash := New(3, func(key []byte) uint32 {
		i, _ := strconv.Atoi(string(key))
		return uint32(i)
	})

	// æ·»åŠ èŠ‚ç‚¹ "2", "4", "6"
	// è™šæ‹ŸèŠ‚ç‚¹ä¼šæœ‰:
	// "2" -> 02, 12, 22
	// "4" -> 04, 14, 24
	// "6" -> 06, 16, 26
	hash.Add("6", "4", "2")

	testCases := map[string]string{
		"2":  "2", // 2 çš„å“ˆå¸Œæ˜¯ 2ï¼ŒåŒ¹é…è™šæ‹ŸèŠ‚ç‚¹ 02ï¼ŒçœŸå®èŠ‚ç‚¹ "2"
		"11": "2", // 11 çš„æœ€è¿‘èŠ‚ç‚¹æ˜¯ 12 (è™šæ‹ŸèŠ‚ç‚¹ 12 å¯¹åº”çœŸå®èŠ‚ç‚¹ "2")
		"23": "4", // 23 çš„æœ€è¿‘èŠ‚ç‚¹æ˜¯ 24 (è™šæ‹ŸèŠ‚ç‚¹ 24 å¯¹åº”çœŸå®èŠ‚ç‚¹ "4")
		"27": "2", // 27 å¤§äºæ‰€æœ‰èŠ‚ç‚¹ï¼Œå›ç¯åˆ° 02 (çœŸå®èŠ‚ç‚¹ "2")
	}

	for k, v := range testCases {
		if hash.Get(k) != v {
			t.Errorf("Asking for %s, should have yielded %s, but got %s", k, v, hash.Get(k))
		}
	}

	// æ·»åŠ èŠ‚ç‚¹ "8"
	// è™šæ‹ŸèŠ‚ç‚¹: 08, 18, 28
	hash.Add("8")

	// 27 æœ¬æ¥æ˜¯ "2"ï¼Œç°åœ¨æœ‰äº† 28ï¼Œåº”è¯¥æ˜ å°„åˆ° "8"
	testCases["27"] = "8"

	for k, v := range testCases {
		if hash.Get(k) != v {
			t.Errorf("Asking for %s, should have yielded %s, but got %s", k, v, hash.Get(k))
		}
	}
}
</file>

<file path="internal/consistenthash/consistenthash.go">
package consistenthash

import (
	"hash/crc32"
	"sort"
	"strconv"
)

// Hash å®šä¹‰å“ˆå¸Œå‡½æ•°çš„å‡½æ•°ç­¾å
// é»˜è®¤ä¸ºcrc32.ChecksumIEEE
type Hash func(data []byte) uint32

// Map æ˜¯ä¸€è‡´æ€§å“ˆå¸Œçš„ä¸»æ•°æ®ç»“æ„
type Map struct {
	hash     Hash           // å“ˆå¸Œå‡½æ•°
	replicas int            // è™šæ‹ŸèŠ‚ç‚¹å€æ•°
	keys     []int          // å“ˆå¸Œç¯ï¼ˆæœ‰åºçš„è™šæ‹ŸèŠ‚ç‚¹å“ˆå¸Œå€¼åˆ—è¡¨ï¼‰
	hashMap  map[int]string //è™šæ‹ŸèŠ‚ç‚¹å“ˆå¸Œå€¼ -> çœŸå®èŠ‚ç‚¹åç§°çš„æ˜ å°„
}

// New åˆ›å»ºä¸€ä¸ªæ–°çš„ Map å®ä¾‹
func New(replicas int, fn Hash) *Map {
	m := &Map{
		replicas: replicas,
		hash:     fn,
		hashMap:  make(map[int]string),
	}
	if m.hash == nil {
		m.hash = crc32.ChecksumIEEE
	}
	return m
}

// Add æ·»åŠ çœŸå®èŠ‚ç‚¹åˆ°å“ˆå¸Œç¯
// keys æ˜¯çœŸå®èŠ‚ç‚¹çš„åç§°ï¼Œä¾‹å¦‚ "10.0.0.1:8080", "10.0.0.2:8080"
// ...string ç­‰ä»·äº []string
// cluster.Add("server1:8080", "server2:8080", "server3:8080")
// å¦‚æœä¸º func (m *Map) Add(keys []string)ï¼Œåˆ™cluster.Add([]string{"server1:8080", "server2:8080", "server3:8080"})
func (m *Map) Add(keys ...string) {
	for _, key := range keys {
		// ä¸ºæ¯ä¸ªçœŸå®èŠ‚ç‚¹åˆ›å»ºm.replicas ä¸ªè™šæ‹ŸèŠ‚ç‚¹
		for i := 0; i < m.replicas; i++ {
			// è™šæ‹ŸèŠ‚ç‚¹çš„åç§°è§„åˆ™ä¸ºï¼šstrconv.Ttoa(i)+key
			//  ä¾‹å¦‚ï¼š010.0.0.1:8080, 110.0.0.1:8080 ...
			hash := int(m.hash([]byte(strconv.Itoa(i) + key)))

			// å°†è™šæ‹ŸèŠ‚ç‚¹çš„å“ˆå¸Œå€¼æ·»åŠ åˆ°å“ˆå¸Œç¯ä¸­
			m.keys = append(m.keys, hash)

			// è®°å½•è™šæ‹ŸèŠ‚ç‚¹å“ˆå¸Œå€¼ä¸çœŸå®èŠ‚ç‚¹åç§°çš„æ˜ å°„å…³ç³»ï¼šè™šæ‹ŸèŠ‚ç‚¹->çœŸå®èŠ‚ç‚¹
			m.hashMap[hash] = key
		}
	}
	// å¯¹ç¯ä¸Šçš„å“ˆå¸Œå€¼è¿›è¡Œæ’åºï¼Œä»¥ä¾¿è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾
	sort.Ints(m.keys)
}

// Get æ ¹æ® key é€‰æ‹©æœ€è¿‘çš„èŠ‚ç‚¹
func (m *Map) Get(key string) string {
	if len(m.keys) == 0 {
		return ""
	}

	// è®¡ç®— key çš„å“ˆå¸Œå€¼
	hash := int(m.hash([]byte(key)))

	// äºŒåˆ†æŸ¥æ‰¾ï¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…çš„è™šæ‹ŸèŠ‚ç‚¹çš„ä¸‹æ ‡
	// sort.Search è¿”å›æ»¡è¶³ func(i) ä¸º true çš„æœ€å° i
	// è¿™é‡Œå³æ‰¾åˆ°ç¬¬ä¸€ä¸ª >= hash çš„è™šæ‹ŸèŠ‚ç‚¹
	idx := sort.Search(len(m.keys), func(i int) bool {
		return m.keys[i] >= hash
	})

	// å¦‚æœ idx == len(m.keys)ï¼Œè¯´æ˜æ²¡æœ‰æ‰¾åˆ° >= hash çš„èŠ‚ç‚¹
	// æ ¹æ®ç¯å½¢ç»“æ„ï¼Œåº”è¯¥æ˜ å°„åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆm.keys[0]ï¼‰
	// æ‰€ä»¥è¿™é‡Œå–æ¨¡æ“ä½œå¤„ç†äº†å›ç¯çš„æƒ…å†µ
	return m.hashMap[m.keys[idx%len(m.keys)]]
}
</file>

<file path="internal/core/lfu/lfu_test.go">
package lfu

import (
	"DistributedCache/internal/core/policy"
	"testing"
)

// mock Value
type String string

func (s String) Len() int { return len(s) }

// ---- Test: Get ----
func TestGet(t *testing.T) {
	lfu := New(0, nil)
	lfu.Add("a", String("111"))

	val, ok := lfu.Get("a")
	if !ok || string(val.(String)) != "111" {
		t.Fatalf("expected a=111, got %v", val)
	}

	if _, ok := lfu.Get("not_found"); ok {
		t.Fatalf("expected miss for not_found")
	}
}

// ---- Test: LFU eviction ----
func TestLFUEviction(t *testing.T) {
	var evictedKey string
	var evictedVal policy.Value

	// å®¹é‡è®¾ä¸º 20ï¼Œé˜²æ­¢æ·»åŠ  k3 æ—¶å› å®¹é‡è¿‡å°å¯¼è‡´ k3 ä¹Ÿè¢«è¿å¸¦æ·˜æ±°
	// k1=6, k2=6, k3=10. æ€»å…± 22. 22-6(k2) = 16 <= 20. å®‰å…¨ã€‚
	lfu := New(20, func(key string, value policy.Value) {
		evictedKey = key
		evictedVal = value
	})

	lfu.Add("k1", String("1111")) // freq=1, ts=1
	lfu.Add("k2", String("2222")) // freq=1, ts=2

	// è®¿é—® k1ï¼Œä½¿å…¶é¢‘ç‡å¢åŠ ï¼Œå¹¶ä¸”æ›´æ–°æ—¶é—´æˆ³
	lfu.Get("k1") // freq(k1)=2, ts=3. æ­¤æ—¶ k1 æ¯” k2 é¢‘ç‡é«˜

	// k2: freq=1
	// k1: freq=2

	// æ·»åŠ  k3ï¼Œè§¦å‘æ·˜æ±°
	lfu.Add("k3", String("33333333")) // freq=1, ts=4

	// æ­¤æ—¶å †ä¸­ï¼šk2(freq=1), k3(freq=1), k1(freq=2)
	// k2 å’Œ k3 é¢‘ç‡ç›¸ç­‰ï¼Œä½† k2 çš„ ts(2) < k3 çš„ ts(4)ï¼Œæ‰€ä»¥ k2 æ›´æ—§ï¼Œåº”æ·˜æ±° k2ã€‚

	if evictedKey != "k2" {
		t.Fatalf("expected k2 evicted, but got %s", evictedKey)
	}
	if evictedVal != String("2222") {
		t.Fatalf("expected 2222, but got %v", evictedVal)
	}
}

// ---- Test: Update value should keep frequency but increase freq by 1 ----
func TestUpdateValue(t *testing.T) {
	l := New(100, nil)

	l.Add("k1", String("abc")) // freq=1
	l.Add("k1", String("xyz")) // freq=2 now

	if l.cache["k1"].freq != 2 {
		t.Fatalf("expected freq=1, got %d", l.cache["k1"].freq)
	}
}

// ---- Test: Remove ----
func TestRemove(t *testing.T) {
	l := New(100, nil)

	l.Add("k1", String("1"))
	l.Add("k2", String("2"))

	l.Remove("k1")

	if _, ok := l.Get("k1"); ok {
		t.Fatalf("expected k1 removed")
	}

	if l.Len() != 1 {
		t.Fatalf("expected len=1, got %d", l.Len())
	}
}

// ---- Test: LFU ordering: lowest frequency first ----
func TestLFUFrequencyOrder(t *testing.T) {
	evicted := ""

	l := New(4, func(key string, value policy.Value) {
		evicted = key
	})

	l.Add("a", String("1")) // freq=1
	l.Add("b", String("2")) // freq=1

	// Increase freq of b
	l.Get("b") // freq=2

	l.Add("c", String("3")) // force eviction

	if evicted != "a" {
		t.Fatalf("expected a (lowest freq) evicted, got %s", evicted)
	}
}
</file>

<file path="internal/core/lru/lru.go">
package lru

import (
	"DistributedCache/internal/core/policy"
	"container/list"
)

// Cache æ˜¯ä¸€ä¸ªLRU ç¼“å­˜
type Cache struct {
	maxBytes  int64                                // å…è®¸ä½¿ç”¨çš„æœ€å¤§å†…å­˜
	nbytes    int64                                // å½“å‰å·²ä½¿ç”¨çš„å†…å­˜
	ll        *list.List                           // åŒå‘é“¾è¡¨
	cache     map[string]*list.Element             //é”®æ˜ å°„åˆ°é“¾è¡¨èŠ‚ç‚¹(list.Element:next, prev *Element,Value)
	OnEvicted func(key string, value policy.Value) // æŸæ¡è®°å½•è¢«ç§»é™¤æ—¶çš„å›è°ƒ,æœ‰äº›ç¼“å­˜å€¼å¯èƒ½æŒæœ‰èµ„æºï¼ˆæ–‡ä»¶ã€è¿æ¥ç­‰ï¼‰ï¼Œéœ€è¦æ­£ç¡®é‡Šæ”¾
}

// é“¾è¡¨å­˜å‚¨çš„æ˜¯ *entryï¼ˆlist.Element.Valueï¼‰ï¼Œåœ¨æ·˜æ±°æœ€æ—§æ•°æ®æ—¶ï¼Œéœ€è¦çŸ¥é“è¦åˆ é™¤çš„key
type entry struct {
	key   string
	value policy.Value
}

// New åˆ›å»ºä¸€ä¸ªæ–°çš„LRU Cache
func New(maxBytes int64, onEvicted func(string, policy.Value)) *Cache {
	return &Cache{
		maxBytes:  maxBytes,
		ll:        list.New(),
		cache:     make(map[string]*list.Element),
		OnEvicted: onEvicted,
	}
}

func (c *Cache) Get(key string) (val policy.Value, ok bool) {
	if ele, exist := c.cache[key]; exist {
		c.ll.MoveToFront(ele)    // LRU æ ¸å¿ƒï¼šè®¿é—®å³ç§»åŠ¨åˆ°é˜Ÿå¤´
		kv := ele.Value.(*entry) // ele.Valueé‡Œé¢å­˜å‚¨çš„æ˜¯ä¸€ä¸ª *entryç±»å‹ï¼ˆentryæŒ‡é’ˆï¼‰
		return kv.value, true
	}
	return
}

func (c *Cache) Add(key string, val policy.Value) {
	if ele, exist := c.cache[key]; exist {
		// æ›´æ–°ç°æœ‰èŠ‚ç‚¹
		c.ll.MoveToFront(ele)
		kv := ele.Value.(*entry)
		c.nbytes = c.nbytes - int64(kv.value.Len()) + int64(val.Len())
		kv.value = val
	} else {
		// æ–°å¢èŠ‚ç‚¹
		ele := c.ll.PushFront(&entry{key, val}) // 1.åˆ›å»ºentryå®ä¾‹å¹¶å–åœ°å€ 2.å°†entryæ’å…¥é“¾è¡¨å¤´éƒ¨ 3.è¿”å›æ–°åˆ›å»ºçš„ *list.Elementï¼ˆé“¾è¡¨èŠ‚ç‚¹ï¼‰
		c.cache[key] = ele
		c.nbytes = c.nbytes + int64(val.Len()) + int64(len(key))
	}

	// å†…å­˜è¶…é™ï¼Œæ·˜æ±°é˜Ÿå°¾
	for c.maxBytes != 0 && c.maxBytes < c.nbytes {
		c.RemoveOldest()
	}
}

func (c *Cache) RemoveOldest() {
	ele := c.ll.Back()
	if ele != nil {
		c.ll.Remove(ele)
		kv := ele.Value.(*entry)
		delete(c.cache, kv.key)
		c.nbytes = c.nbytes - int64(len(kv.key)) - int64(kv.value.Len())
		if c.OnEvicted != nil {
			c.OnEvicted(kv.key, kv.value)
		}
	}
}

func (c *Cache) Remove(key string) {
	if ele, exist := c.cache[key]; exist {
		c.removeElement(ele)
	}
}

func (c *Cache) removeElement(ele *list.Element) {
	c.ll.Remove(ele)
	kv := ele.Value.(*entry)
	delete(c.cache, kv.key)
	c.nbytes = c.nbytes - int64(len(kv.key)) - int64(kv.value.Len())
	if c.OnEvicted != nil {
		c.OnEvicted(kv.key, kv.value)
	}
}

func (c *Cache) Len() int {
	return c.ll.Len()
}
</file>

<file path="internal/core/policy/types.go">
package policy

// Value æ˜¯ç¼“å­˜ä¸­å­˜å‚¨çš„å€¼å¿…é¡»å®ç°çš„æ¥å£
// Len è¿”å›è¯¥å€¼å ç”¨çš„å†…å­˜å¤§å°ï¼ˆå­—èŠ‚æ•°ï¼‰

// ä¸€ä¸ªåä¸º Valueçš„æ¥å£ç±»å‹ï¼Œè¿™ä¸ªæ¥å£åªè¦æ±‚å®ç°ä¸€ä¸ªæ–¹æ³•ï¼šLen() int
// ä»»ä½•å®ç°äº† Len() intæ–¹æ³•çš„ç±»å‹éƒ½å¯ä»¥è¢«å½“ä½œ Valueæ¥å£ä½¿ç”¨
type Value interface {
	Len() int
}

// EvictionPolicy å®šä¹‰äº†æ·˜æ±°ç­–ç•¥çš„é€šç”¨æ¥å£
type EvictionPolicy interface {
	// Get è·å–ç¼“å­˜å€¼
	Get(key string) (Value, bool)

	// Add æ·»åŠ æˆ–æ›´æ–°ç¼“å­˜å€¼
	Add(key string, value Value)

	// Remove ç§»é™¤æŒ‡å®škey
	Remove(key string)

	// Len  è¿”å›å½“å‰ç¼“å­˜çš„æ¡ç›®æ•°
	Len() int
}
</file>

<file path="internal/discovery/discovery.go">
package discovery

import (
	"context"
	"log"
	"sync"
	"time"

	clientv3 "go.etcd.io/etcd/client/v3"
)

// Discovery è´Ÿè´£å‘ç°æœåŠ¡
// åŠŸèƒ½ï¼šç›‘å¬ etcd ä¸­ç‰¹å®šå‰ç¼€çš„æœåŠ¡èŠ‚ç‚¹å˜åŒ–ï¼Œç»´æŠ¤å®æ—¶èŠ‚ç‚¹åˆ—è¡¨
type Discovery struct {
	cli       *clientv3.Client
	prefix    string   //ç›‘å¬çš„æœåŠ¡å‰ç¼€ï¼Œå¦‚ "distributed-cache/nodes"
	serverMap sync.Map // çº¿ç¨‹å®‰å…¨çš„èŠ‚ç‚¹æ˜ å°„è¡¨ï¼Œå­˜å‚¨å½“å‰åœ¨çº¿çš„èŠ‚ç‚¹åœ°å€ // ä½¿ç”¨ sync.Map æ›¿ä»£ map[string]struct{} ä»¥è·å¾—æ›´å¥½çš„å¹¶å‘æ€§èƒ½
}

// NewDiscovery åˆ›å»ºä¸€ä¸ªå‘ç°å™¨
func NewDiscovery(endpoints []string) (*Discovery, error) {
	cli, err := clientv3.New(clientv3.Config{
		Endpoints:   endpoints,
		DialTimeout: 5 * time.Second,
	})
	if err != nil {
		return nil, err
	}

	return &Discovery{
		cli: cli,
	}, nil
}

// WatchService å¼€å§‹ç›‘å¬æœåŠ¡èŠ‚ç‚¹å˜åŒ–
// prefix:ç›‘å¬çš„å‰ç¼€ï¼Œä¾‹å¦‚ "distributed-cache/nodes"
// updatePeers: å›è°ƒå‡½æ•°ï¼Œå½“èŠ‚ç‚¹åˆ—è¡¨å˜åŒ–æ—¶è¢«è°ƒç”¨ï¼Œå‚æ•°æ˜¯æ–°çš„èŠ‚ç‚¹åœ°å€åˆ—è¡¨
// å·¥ä½œæµç¨‹:
//  1. è·å–å½“å‰å·²å­˜åœ¨çš„èŠ‚ç‚¹ï¼ˆåˆå§‹åŒ–ï¼‰
//  2. å¼€å¯ Watch åç¨‹ç›‘å¬åç»­å˜åŒ–
func (d *Discovery) WatchService(prefix string, updatePeers func([]string)) error {
	d.prefix = prefix

	// 1. åˆå§‹åŒæ­¥ï¼šè·å–å½“å‰ etcd ä¸­å·²å­˜åœ¨çš„æ‰€æœ‰èŠ‚ç‚¹
	// WithPrefix() è¡¨ç¤ºè·å–æ‰€æœ‰ä»¥ prefix å¼€å¤´çš„é”®
	resp, err := d.cli.Get(context.Background(), prefix, clientv3.WithPrefix())
	if err != nil {
		return err
	}

	var nodes []string
	// éå†æ‰€æœ‰æ‰¾åˆ°çš„é”®å€¼å¯¹
	for _, kv := range resp.Kvs {
		node := string(kv.Value) // kv.Value å­˜å‚¨çš„æ˜¯èŠ‚ç‚¹åœ°å€ï¼Œå¦‚ "localhost:8001"
		// sync.Map.Store æ˜¯çº¿ç¨‹å®‰å…¨çš„å­˜å‚¨æ“ä½œ
		// å°†èŠ‚ç‚¹æ·»åŠ åˆ° serverMap ä¸­
		d.serverMap.Store(node, struct{}{})
		nodes = append(nodes, node)
	}

	// åˆå§‹åŒ– Hash ç¯ï¼ˆç”±è°ƒç”¨æ–¹ updatePeers å®ç°ï¼‰
	if len(nodes) > 0 {
		updatePeers(nodes)
		log.Printf("[Discovery] Initial nodes found: %v", nodes)
	}

	// 2. å¼€å¯ Watch åç¨‹ç›‘å¬åç»­å˜åŒ–
	// è¿™ä¸ªåç¨‹ä¼šä¸€ç›´è¿è¡Œï¼Œç›´åˆ° etcd è¿æ¥å…³é—­
	go d.wacher(prefix, updatePeers)
	return nil
}

// watcher ç›‘å¬ etcd é”®ç©ºé—´å˜åŒ–
// è¿™æ˜¯æœåŠ¡å‘ç°çš„æ ¸å¿ƒé€»è¾‘ï¼Œé€šè¿‡ etcd çš„ Watch æœºåˆ¶å®æ—¶æ„ŸçŸ¥èŠ‚ç‚¹ä¸Šä¸‹çº¿
// prefix: ç›‘å¬çš„å‰ç¼€
// updatePeers: èŠ‚ç‚¹å˜åŒ–æ—¶çš„å›è°ƒå‡½æ•°
func (d *Discovery) wacher(prefix string, updatePeers func([]string)) {
	// åˆ›å»º Watch é€šé“
	// WithPrefix() è¡¨ç¤ºç›‘å¬æ‰€æœ‰ä»¥ prefix å¼€å¤´çš„é”®çš„å˜åŒ–
	rch := d.cli.Watch(context.Background(), prefix, clientv3.WithPrefix())
	log.Printf("[Discovery] Watching prefix: %s", prefix)

	for wresp := range rch {
		for _, ev := range wresp.Events {
			switch ev.Type {
			case clientv3.EventTypePut: // æ–°å¢æˆ–ä¿®æ”¹
				node := string(ev.Kv.Value) // ä» Value è·å–èŠ‚ç‚¹åœ°å€
				d.serverMap.Store(node, struct{}{})
				log.Printf("[Discovery] Node added: %s", node)
			case clientv3.EventTypeDelete: // åˆ é™¤
				// key æ˜¯ serviceName/nodeAddrï¼Œæˆ‘ä»¬éœ€è¦ä» Key ä¸­æå–æˆ–è€…ç›´æ¥å­˜ Value å³å¯
				// åœ¨ Register ä¸­æˆ‘ä»¬ Key åŒ…å«äº†åœ°å€ï¼Œä½† Value ä¹Ÿæ˜¯åœ°å€ï¼Œè¿™é‡Œä¾èµ– Value æ¯”è¾ƒæ–¹ä¾¿
				// æ³¨æ„ï¼šåˆ é™¤äº‹ä»¶å¯èƒ½æ²¡æœ‰ Valueï¼Œéœ€è¦æ ¹æ® Key è§£æï¼Œæˆ–è€…ä¾èµ–ä¹‹å‰çš„é€»è¾‘
				key := string(ev.Kv.Key)
				node := key[len(prefix)+1:] // +1 æ˜¯ä¸ºäº†å»æ‰åˆ†éš”ç¬¦ "/"
				d.serverMap.Delete(node)
				log.Printf("[Discovery] Node removed: %s", node)
			}
		}

		// æ¯æ¬¡äº‹ä»¶å‘ç”Ÿåï¼Œé‡å»ºèŠ‚ç‚¹åˆ—è¡¨å¹¶é€šçŸ¥å›è°ƒ
		var nodes []string
		d.serverMap.Range(func(key, value interface{}) bool {
			nodes = append(nodes, key.(string))
			return true
		})
		updatePeers(nodes)
	}
}

// Stop å…³é—­è¿æ¥
func (d *Discovery) Stop() error {
	return d.cli.Close()
}
</file>

<file path="internal/discovery/register.go">
package discovery

// æ­£ç¡®çš„å¯¼å…¥è·¯å¾„
import (
	"context"
	"log"
	"time"

	clientv3 "go.etcd.io/etcd/client/v3" // æ³¨æ„è¿™é‡Œ
)

// æ³¨æ„è¿™é‡Œ

// Register è´Ÿè´£å‘ Etcd æ³¨å†ŒæœåŠ¡å¹¶ä¿æŒå¿ƒè·³
type Register struct {
	cli         *clientv3.Client                        // etcd å®¢æˆ·ç«¯å®ä¾‹ï¼Œç”¨äºä¸ etcd é›†ç¾¤é€šä¿¡
	leaseID     clientv3.LeaseID                        // ç§Ÿçº¦ IDï¼Œç”¨äºè®¾ç½®é”®å€¼å¯¹çš„ç”Ÿå­˜æ—¶é—´ï¼ˆTTLï¼‰
	keepaliveCh <-chan *clientv3.LeaseKeepAliveResponse // å¿ƒè·³å“åº”é€šé“ï¼Œæ¥æ”¶ etcd çš„å¿ƒè·³ç¡®è®¤
	closeCh     chan struct{}                           // å…³é—­ä¿¡å·é€šé“ï¼Œç”¨äºä¼˜é›…åœæ­¢æ³¨å†Œå’Œå¿ƒè·³
}

// NewRegister åˆ›å»ºä¸€ä¸ªæ³¨å†Œå™¨
// endpoints []string - etcd é›†ç¾¤çš„åœ°å€åˆ—è¡¨ï¼Œå¦‚ []string{"localhost:2379", "192.168.1.1:2379"}
// ä¸»è¦èŒè´£:
//  1. å»ºç«‹ä¸ etcd é›†ç¾¤çš„è¿æ¥
//  2. åˆå§‹åŒ– Register ç»“æ„ä½“çš„å„ä¸ªå­—æ®µ
//  3. ä¸ºä¼˜é›…å…³é—­å‡†å¤‡å¿…è¦çš„é€šé“
func NewRegister(endpoints []string) (*Register, error) {
	// clientv3.New æ˜¯ etcd å®˜æ–¹å®¢æˆ·ç«¯åº“æä¾›çš„æ„é€ å‡½æ•°
	cli, err := clientv3.New(clientv3.Config{
		Endpoints:   endpoints,
		DialTimeout: 5 * time.Second, // å¦‚æœ5ç§’å†…æ²¡æœ‰å»ºç«‹è¿æ¥ï¼Œè¿”å›è¶…æ—¶é”™è¯¯,å®¢æˆ·ç«¯ä¼šç»§ç»­å°è¯•å…¶ä»– endpoint
	})
	if err != nil {
		return nil, err
	}

	//   - leaseID:     ç§Ÿçº¦IDï¼ˆè¿˜æœªåˆ›å»ºç§Ÿçº¦ï¼‰
	//   - keepaliveCh: å¿ƒè·³é€šé“ï¼ˆè¿˜æœªå¼€å§‹å¿ƒè·³ï¼‰
	return &Register{
		cli:     cli,
		closeCh: make(chan struct{}),
	}, nil
}

// Register æ³¨å†ŒæœåŠ¡,å°†å½“å‰èŠ‚ç‚¹æ³¨å†Œåˆ° etcd æœåŠ¡å‘ç°ç³»ç»Ÿ
// serviceName : æœåŠ¡åç§°ï¼Œä¾‹å¦‚ "distributed-cache/nodes"
// nodeAddr: å½“å‰èŠ‚ç‚¹åœ°å€ï¼Œä¾‹å¦‚ "localhost:8001"
// ttl: ç§Ÿçº¦è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰

// å·¥ä½œæµç¨‹:
//  1. åˆ›å»ºç§Ÿçº¦ï¼ˆè®¾ç½®TTLï¼‰
//  2. å°†æœåŠ¡ä¿¡æ¯å†™å…¥ etcd å¹¶ç»‘å®šç§Ÿçº¦
//  3. å¯åŠ¨å¿ƒè·³ä¿æŒç§Ÿçº¦æœ‰æ•ˆ
//  4. å¼€å¯ç›‘å¬åç¨‹å¤„ç†å¿ƒè·³å“åº”
func (r *Register) Register(serviceName string, nodeAddr string, ttl int64) error {
	// 1. åˆ›å»ºç§Ÿçº¦
	lease := clientv3.NewLease(r.cli)
	// å‘ etcd ç”³è¯·ä¸€ä¸ªç§Ÿçº¦ï¼ŒæŒ‡å®š TTLï¼ˆTime To Liveï¼‰
	// ä¾‹å¦‚ ttl=10 è¡¨ç¤ºï¼šå¦‚æœ10ç§’å†…æ²¡æœ‰ç»­çº¦ï¼Œç§Ÿçº¦ä¼šè‡ªåŠ¨è¿‡æœŸ
	grantResp, err := lease.Grant(context.Background(), ttl)
	if err != nil {
		return nil
	}
	r.leaseID = grantResp.ID

	// 2. å†™å…¥é”®å€¼å¯¹(Key: serviceName/nodeAddr, Value: nodeAddr) å¹¶ç»‘å®šç§Ÿçº¦
	// ä¾‹å¦‚ Key: "distributed-cache/nodes/localhost:8001"
	key := serviceName + "/" + nodeAddr
	kv := clientv3.NewKV(r.cli) // // åˆ›å»º KV å®¢æˆ·ç«¯ï¼Œç”¨äºæ“ä½œé”®å€¼å¯¹
	// WithLease(r.leaseID) æ˜¯å…³é”®ï¼šå°†æ­¤é”®å€¼å¯¹ä¸ç§Ÿçº¦å…³è”
	_, err = kv.Put(context.Background(), key, nodeAddr, clientv3.WithLease(r.leaseID))
	if err != nil {
		return err
	}

	// 3. è®¾ç½® KeepAlive è‡ªåŠ¨ç»­ç§Ÿ
	// å¯åŠ¨å¿ƒè·³æœºåˆ¶ï¼Œå®šæœŸå‘ etcd å‘é€ç»­ç§Ÿè¯·æ±‚
	// å¦‚æœèŠ‚ç‚¹æ­£å¸¸è¿è¡Œï¼Œç§Ÿçº¦ä¼šä¸€ç›´ç»­æœŸï¼ŒæœåŠ¡ä¿¡æ¯å°±ä¸ä¼šè¿‡æœŸ
	keepAliveCh, err := lease.KeepAlive(context.Background(), r.leaseID)
	if err != nil {
		return err
	}
	r.keepaliveCh = keepAliveCh

	log.Printf("[Discovery] Registered node: %s with TTL: %d", key, ttl)
	// 4. å¼€å¯åç¨‹ç›‘å¬ç»­ç§Ÿå“åº”ï¼Œå¤„ç†è¿æ¥æ–­å¼€çš„æƒ…å†µ
	// è¿™ä¸ªåç¨‹ä¼šä¸€ç›´è¿è¡Œï¼Œç›´åˆ°æ”¶åˆ°å…³é—­ä¿¡å·æˆ–å¿ƒè·³å¤±è´¥
	go r.watcher()
	return nil
}

// watcher ç›‘å¬ç»­ç§Ÿé€šé“ï¼Œå¤„ç†å¿ƒè·³å“åº”
// è¿™ä¸ªåç¨‹è´Ÿè´£ï¼š
//  1. ç›‘æ§å¿ƒè·³æ˜¯å¦æ­£å¸¸
//  2. å¤„ç†å¿ƒè·³å¤±è´¥çš„æƒ…å†µ
//  3. å“åº”å…³é—­ä¿¡å·
func (r *Register) watcher() {
	for {
		select {
		case <-r.closeCh:
			// æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œä¼˜é›…é€€å‡ºåç¨‹
			// è¿™é€šå¸¸å‘ç”Ÿåœ¨è°ƒç”¨ Stop() æ–¹æ³•æ—¶
			return
		case res, ok := <-r.keepaliveCh:
			if !ok {
				log.Println("[Discovery] Lease keep-alive channel closed, stopping watcher")
				return
			}
			// æ‰“å°å¿ƒè·³æ—¥å¿—
			// æˆåŠŸæ”¶åˆ°å¿ƒè·³å“åº”
			// res åŒ…å«ç»­ç§Ÿç¡®è®¤ä¿¡æ¯
			// æ­¤æ—¶ç§Ÿçº¦çš„ TTL ä¼šè¢«é‡ç½®ï¼Œé‡æ–°å¼€å§‹è®¡æ—¶
			log.Printf("[Discovery] Lease renewed: %d", res.ID)
			_ = res
		}
	}
}

// Stop åœæ­¢æ³¨å†ŒæœåŠ¡
func (r *Register) Stop() error {
	// 1. å…³é—­å…³é—­ä¿¡å·é€šé“ï¼Œé€šçŸ¥æ‰€æœ‰åç¨‹é€€å‡º
	// è¿™æ˜¯ Go ä¸­é€šçŸ¥å¤šä¸ªåç¨‹é€€å‡ºçš„å¸¸ç”¨æ¨¡å¼
	close(r.closeCh)
	// æ’¤é”€ç§Ÿçº¦ï¼ŒEtcd ä¼šè‡ªåŠ¨åˆ é™¤ç»‘å®šçš„ Key
	// å¦‚æœæ²¡æœ‰æ‰§è¡Œè¿™ä¸€æ­¥ï¼Œetcd ä¼šç­‰å¾…ç§Ÿçº¦è‡ªç„¶è¿‡æœŸåæ‰åˆ é™¤
	if _, err := r.cli.Revoke(context.Background(), r.leaseID); err != nil {
		return err
	}
	return r.cli.Close()
}
</file>

<file path="internal/group/peers.go">
package group

import pb "DistributedCache/api/cachepb"

// åˆ†å¸ƒå¼ç¼“å­˜èŠ‚ç‚¹é€šä¿¡çš„æ¥å£æŠ½è±¡å±‚

// PeerPicker  æ˜¯å¿…é¡»å®ç°çš„æ¥å£ï¼Œç”¨äºæ ¹æ® Key é€‰æ‹©å¯¹åº”çš„èŠ‚ç‚¹ï¼ˆåŸºäºä¸€è‡´æ€§å“ˆå¸Œï¼‰
type PeerPicker interface {
	// PickPeer æ ¹æ® key é€‰æ‹©èŠ‚ç‚¹
	// è¿”å› peer èŠ‚ç‚¹æŠ½è±¡ï¼ˆç”¨äºé€šä¿¡ï¼‰å’Œ trueï¼ˆå¦‚æœæ‰¾åˆ°äº†éæœ¬åœ°èŠ‚ç‚¹ï¼‰
	PickPeer(key string) (peer PeerGetter, ok bool)
}

// PeerGetter æ˜¯èŠ‚ç‚¹å®¢æˆ·ç«¯å¿…é¡»å®ç°çš„æ¥å£
// å¯¹åº”äº HTTP å®¢æˆ·ç«¯æˆ– gRPC å®¢æˆ·ç«¯
// ç”¨äºä»é‚£ä¸ªèŠ‚ç‚¹è·å–æ•°æ®ï¼ˆåŸºäº Protobufï¼‰
type PeerGetter interface {
	// Get ä»å¯¹åº”ç»„æŸ¥æ‰¾ç¼“å­˜å€¼
	Get(in *pb.GetRequest, out *pb.GetResponse) error
}
</file>

<file path="internal/server/grpc.go">
package server

import (
	"context"
	"fmt"
	"log"
	"net"
	"sync"

	pb "DistributedCache/api/cachepb"
	"DistributedCache/internal/consistenthash"
	"DistributedCache/internal/group"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// Server æ¨¡å—æ‰®æ¼”ä¸‰ä¸ªè§’è‰²ï¼š
// 1. gRPC æœåŠ¡å™¨ï¼šæ¥æ”¶å…¶ä»–èŠ‚ç‚¹æˆ–å®¢æˆ·ç«¯çš„è¯·æ±‚
// 2. èŠ‚ç‚¹é€‰æ‹©å™¨ï¼ˆPeerPickerï¼‰ï¼šåŸºäºä¸€è‡´æ€§å“ˆå¸Œä¸º key é€‰æ‹©è¿œç¨‹èŠ‚ç‚¹
// 3. å®¢æˆ·ç«¯ç®¡ç†ï¼šä¸ºæ¯ä¸ªè¿œç¨‹èŠ‚ç‚¹ç»´æŠ¤ä¸€ä¸ª grpcGetterï¼ˆå®ç° PeerGetterï¼‰
// æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰è‡ªå·±çš„ Server å®ä¾‹
type Server struct {
	pb.UnimplementedGroupCacheServer                        // å¿…é¡»åµŒå…¥ï¼Œä»¥å…¼å®¹ gRPC æ¥å£
	self                             string                 // å½“å‰èŠ‚ç‚¹åœ°å€ï¼Œä¾‹å¦‚â€localhost:8001â€œ
	mu                               sync.Mutex             // ä¿æŠ¤ peers å’Œ peersGetter
	peers                            *consistenthash.Map    // ä¸€è‡´æ€§å“ˆå¸Œç¯
	peersGetter                      map[string]*grpcGetter // æ˜ å°„ï¼šè¿œç¨‹èŠ‚ç‚¹åœ°å€ -> gRPC å®¢æˆ·ç«¯
}

func NewServer(self string) *Server {
	return &Server{
		self:        self,
		peers:       consistenthash.New(50, nil),
		peersGetter: make(map[string]*grpcGetter),
	}
}

// Start å¯åŠ¨ gRPC æœåŠ¡ç«¯ç›‘å¬
func (s *Server) Start() error {
	lis, err := net.Listen("tcp", s.self) // åœ¨ s.selfæŒ‡å®šçš„åœ°å€ä¸Šè¿›è¡Œ TCP ç›‘å¬
	if err != nil {
		return fmt.Errorf("failed to listen at %s: %v", s.self, err)
	}
	grpcServer := grpc.NewServer()             // è°ƒç”¨ grpc åŒ…çš„ NewServer å‡½æ•°
	pb.RegisterGroupCacheServer(grpcServer, s) // æŠŠç¼“å­˜æœåŠ¡æŒ‚åˆ° gRPC æœåŠ¡å™¨ä¸Šï¼Œè®©å¤–éƒ¨å¯ä»¥è°ƒç”¨

	s.Log("gRPC server listening at %s", s.self)
	return grpcServer.Serve(lis)
}

// Get å¤„ç†æ¥è‡ªå…¶ä»–èŠ‚ç‚¹æˆ–å®¢æˆ·ç«¯çš„gRPC Getè¯·æ±‚
// è¿™æ˜¯Serverçš„Getï¼ˆæ¥ç”µè¯ï¼‰ï¼Œè°ƒç”¨æ—¶æœºâ€‹ï¼šå…¶ä»–èŠ‚ç‚¹/å®¢æˆ·ç«¯è¯·æ±‚æ•°æ®æ—¶
func (s *Server) Get(ctx context.Context, req *pb.GetRequest) (*pb.GetResponse, error) {
	groupName := req.GetGroup()
	key := req.GetKey()

	if groupName == "" || key == "" {
		return nil, fmt.Errorf("invalid request: group or key is empty")
	}

	// æ‰¾åˆ°å¯¹åº”çš„ Group
	g := group.GetGroup(groupName)
	if g == nil {
		return nil, fmt.Errorf("no such group: %s", groupName)
	}

	// è°ƒç”¨ Group.Get è·å–æ•°æ® (å†…éƒ¨å¯èƒ½è§¦å‘å›æºæˆ–è¿œç¨‹æ‹‰å–ï¼‰
	view, err := g.Get(key)
	if err != nil {
		return nil, err
	}
	return &pb.GetResponse{Value: view.ByteSlice()}, nil
}

// SetPeers è®¾ç½®ï¼ˆæˆ–æ›´æ–°ï¼‰å“ˆå¸Œç¯ä¸Šçš„èŠ‚ç‚¹åˆ—è¡¨
func (s *Server) SetPeers(peers ...string) {
	s.mu.Lock()
	defer s.mu.Unlock()

	// é‡å»ºå“ˆå¸Œç¯
	s.peers = consistenthash.New(50, nil)
	s.peers.Add(peers...) // å°†æ‰€æœ‰èŠ‚ç‚¹æ·»åŠ åˆ°å“ˆå¸Œç¯ä¸­

	// é‡å»ºè¿œç¨‹ Getter æ˜ å°„(åˆ›å»ºæ–°çš„ mapæ¥å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„å®¢æˆ·ç«¯è¿æ¥)
	// é”®ï¼šèŠ‚ç‚¹åœ°å€ï¼ˆå¦‚ "192.168.1.1:8000"ï¼‰
	// å€¼ï¼šgrpcGetterå¯¹è±¡ï¼Œç”¨äºå‘è¯¥èŠ‚ç‚¹å‘èµ·RPCè°ƒç”¨
	// ä¸ºæ¯ä¸ªçœŸå®èŠ‚ç‚¹é…ç½®ä¸€ä¸ªgRPCå®¢æˆ·ç«¯
	s.peersGetter = make(map[string]*grpcGetter, len(peers))
	for _, peer := range peers {
		s.peersGetter[peer] = &grpcGetter{addr: peer}
	}
	s.Log("peers set: %v", peers)
}

// PickPeer æ ¹æ® key é€‰æ‹©å¯¹åº”çš„è¿œç¨‹èŠ‚ç‚¹çš„grpcå®¢æˆ·ç«¯
// å®ç° group.PeerPicker æ¥å£
func (s *Server) PickPeer(key string) (group.PeerGetter, bool) {
	s.mu.Lock()
	defer s.mu.Unlock()

	// ä¸€è‡´æ€§å“ˆå¸Œç¯ä¸ºç©º
	if s.peers == nil {
		return nil, false
	}
	peerAddr := s.peers.Get(key) // æ ¹æ® key é€‰æ‹©ä¸€è‡´æ€§å“ˆå¸Œç¯æœ€è¿‘çš„èŠ‚ç‚¹
	// å¦‚æœé€‰åˆ°çš„æ˜¯éæœ¬èŠ‚ç‚¹ï¼Œåˆ™è¿”å›å¯¹åº”çš„getter
	if peerAddr != "" && peerAddr != s.self {
		getter := s.peersGetter[peerAddr] // æ‰¾åˆ°å¯¹åº”èŠ‚ç‚¹çš„grpcå®¢æˆ·ç«¯
		if getter != nil {
			s.Log("Pick remote peer %s for key=%s", peerAddr, key)
			return getter, true
		}
	}
	return nil, false
}

// grpcGetter è¡¨ç¤ºä¸€ä¸ªè¿œç¨‹èŠ‚ç‚¹çš„ gRPC å®¢æˆ·ç«¯ï¼Œå®ç° group.PeerGetter
type grpcGetter struct {
	addr string
}

// Log è¾…åŠ©æ—¥å¿—
func (s *Server) Log(format string, v ...interface{}) {
	log.Printf("[Server %s] %s", s.self, fmt.Sprintf(format, v...))
}

// Get é€šè¿‡ gRPC å®¢æˆ·ç«¯å‘è¿œç«¯èŠ‚ç‚¹è·å–å€¼
// g *grpcGetterï¼šæ¥æ”¶è€…ï¼Œè¡¨ç¤ºå®¢æˆ·ç«¯å®ä¾‹
// in *pb.GetRequestï¼šè¾“å…¥å‚æ•°ï¼ŒåŒ…å«è¦è·å–çš„æ•°æ®çš„keyå’Œgroup
// out *pb.GetResponseï¼šè¾“å‡ºå‚æ•°ï¼Œç”¨äºæ¥æ”¶è¿”å›çš„æ•°æ®
// å®¢æˆ·ç«¯ï¼ˆæ‰“ç”µè¯ï¼‰,éœ€è¦å‘è¿œç¨‹èŠ‚ç‚¹è¯·æ±‚æ•°æ®æ—¶
func (g *grpcGetter) Get(in *pb.GetRequest, out *pb.GetResponse) error {
	// 1. ğŸ“ æ‰“ç”µè¯ç»™è¿œç¨‹èŠ‚ç‚¹
	// å»ºç«‹åˆ°è¿œç¨‹èŠ‚ç‚¹çš„gRPCè¿æ¥,g.addrï¼šè¿œç¨‹èŠ‚ç‚¹åœ°å€ï¼ˆå¦‚ "192.168.1.1:8000"ï¼‰
	// insecure.NewCredentials()ï¼šä½¿ç”¨ä¸å®‰å…¨çš„è¿æ¥ï¼ˆæ— TLSåŠ å¯†ï¼‰
	// defer conn.Close()ï¼šç¡®ä¿å‡½æ•°ç»“æŸæ—¶å…³é—­è¿æ¥
	conn, err := grpc.Dial(g.addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return fmt.Errorf("dial %s failed: %v", g.addr, err)
	}
	defer conn.Close()

	// é€šè¿‡è¿æ¥åˆ›å»ºgRPCå®¢æˆ·ç«¯
	// 2. ğŸ—£ï¸ è¯´ï¼š"æˆ‘è¦è¿™ä¸ªæ•°æ®"
	client := pb.NewGroupCacheClient(conn)
	resp, err := client.Get(context.Background(), in)
	if err != nil {
		return fmt.Errorf("rpc Get to %s failed: %v", g.addr, err)
	}
	// 3. ğŸ‘‚ å¬å¯¹æ–¹å›å¤
	out.Value = resp.Value
	return nil
}
</file>

<file path="internal/server/http.go">
package server

import (
	"DistributedCache/internal/group"
	"log"
	"net/http"
)

// StartHTTP å¯åŠ¨ä¸€ä¸ªç®€å•çš„ HTTP æœåŠ¡å™¨ç”¨äºè°ƒè¯•
// è®¿é—®æ ¼å¼ï¼š/api?group=xxx&key=xxx
func StartHTTP(addr string) {
	http.HandleFunc("/api", func(w http.ResponseWriter, r *http.Request) {
		key := r.URL.Query().Get("key")
		groupName := r.URL.Query().Get("group")

		if key == "" || groupName == "" {
			http.Error(w, "missing key or group", http.StatusBadRequest)
			return
		}

		g := group.GetGroup(groupName)
		if g == nil {
			http.Error(w, "no such group: "+groupName, http.StatusNotFound)
			return
		}

		view, err := g.Get(key)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/octet-stream")
		w.Write(view.ByteSlice())
	})
	log.Println("HTTP server is running at", addr)
	log.Fatal(http.ListenAndServe(addr, nil))
}
</file>

<file path="internal/server/server_test.go">
package server

import (
	"context"
	"fmt"
	"testing"
	"time"

	pb "DistributedCache/api/cachepb"
	"DistributedCache/internal/group"
)

// ---------------------------------------------------------------------
// 1. è¾…åŠ©å·¥å…·ä¸ Mock
// ---------------------------------------------------------------------

// mockGetter æ¨¡æ‹Ÿæ•°æ®åº“å›æºæ“ä½œ
type mockGetter map[string][]byte

func (m mockGetter) Get(key string) ([]byte, error) {
	if v, ok := m[key]; ok {
		return v, nil
	}
	return nil, fmt.Errorf("key not found in db: %s", key)
}

// setupTestGroup è¾…åŠ©å‡½æ•°ï¼Œç”¨äºåœ¨æµ‹è¯•å‰åˆå§‹åŒ–ä¸€ä¸ª Group
func setupTestGroup(name string) *group.Group {
	db := mockGetter{
		"Tom":   []byte("630"),
		"Jack":  []byte("589"),
		"Sam":   []byte("567"),
		"Alice": []byte("12345"),
	}
	// åˆ›å»ºä¸€ä¸ª Groupï¼Œé…ç½®è¾ƒå°çš„ç¼“å­˜ä»¥ä¾¿æµ‹è¯•
	return group.NewGroup(name, 2<<10, "lru", group.GetterFunc(db.Get))
}

// ---------------------------------------------------------------------
// 2. å•å…ƒæµ‹è¯•
// ---------------------------------------------------------------------

// TestPickPeer æµ‹è¯•ä¸€è‡´æ€§å“ˆå¸Œçš„èŠ‚ç‚¹é€‰æ‹©é€»è¾‘
func TestPickPeer(t *testing.T) {
	// 1. åˆ›å»º Serverï¼Œå‡è®¾å½“å‰èŠ‚ç‚¹æ˜¯ç«¯å£ 8000
	s := NewServer("localhost:8000")

	// 2. è®¾ç½® Peer åˆ—è¡¨
	s.SetPeers("localhost:8000", "localhost:8001", "localhost:8002")

	// 3. æµ‹è¯•ç”¨ä¾‹
	// æ³¨æ„ï¼šä¸€è‡´æ€§å“ˆå¸Œçš„ç»“æœå–å†³äºå…·ä½“çš„ Hash ç®—æ³•ï¼ˆé€šå¸¸æ˜¯ CRC32ï¼‰ã€‚
	// è¿™é‡Œæˆ‘ä»¬ä¸»è¦æµ‹è¯•ï¼š
	// a. PickPeer æ˜¯å¦èƒ½è¿”å› true/false
	// b. é€‰ä¸­è‡ªå·±æ—¶åº”è¿”å› false
	// c. é€‰ä¸­è¿œç¨‹æ—¶åº”è¿”å› true ä¸” getter ä¸ä¸ºç©º

	// æˆ‘ä»¬éå†ä¸€äº› keyï¼Œåªè¦èƒ½è¦†ç›–åˆ° "é€‰ä¸­è‡ªå·±" å’Œ "é€‰ä¸­åˆ«äºº" ä¸¤ç§æƒ…å†µå³å¯
	hitSelf := false
	hitRemote := false

	keys := []string{"1", "2", "3", "4", "5", "key_a", "key_b"}
	for _, key := range keys {
		picker, ok := s.PickPeer(key)
		if !ok {
			// ç†è®ºä¸Šæ˜¯é€‰ä¸­äº†è‡ªå·± (localhost:8000)
			hitSelf = true
			t.Logf("Key [%s] picked self (local)", key)
		} else {
			// é€‰ä¸­äº†è¿œç¨‹èŠ‚ç‚¹
			hitRemote = true
			// éªŒè¯ picker ç±»å‹
			if _, ok := picker.(*grpcGetter); !ok {
				t.Errorf("Peer getter should be type *grpcGetter")
			}
			t.Logf("Key [%s] picked remote peer", key)
		}
	}

	if !hitSelf {
		t.Log("Warning: Test didn't hit 'self' node, might need more keys or specific hash calculation")
	}
	if !hitRemote {
		t.Error("Error: Test failed to pick any remote peer")
	}
}

// TestServer_Get_Direct æµ‹è¯• Server.Get æ–¹æ³•çš„æ ¸å¿ƒé€»è¾‘ï¼ˆä¸èµ°ç½‘ç»œï¼Œç›´æ¥å‡½æ•°è°ƒç”¨ï¼‰
func TestServer_Get_Direct(t *testing.T) {
	groupName := "scores_direct"
	setupTestGroup(groupName)

	s := NewServer("localhost:9999")

	// æµ‹è¯•æ­£å¸¸æƒ…å†µ
	req := &pb.GetRequest{
		Group: groupName,
		Key:   "Tom",
	}

	resp, err := s.Get(context.Background(), req)
	if err != nil {
		t.Fatalf("Server.Get failed: %v", err)
	}

	if string(resp.Value) != "630" {
		t.Errorf("Expected value '630', got '%s'", string(resp.Value))
	}

	// æµ‹è¯•ä¸å­˜åœ¨çš„ Group
	reqBadGroup := &pb.GetRequest{Group: "unknown_group", Key: "Tom"}
	if _, err := s.Get(context.Background(), reqBadGroup); err == nil {
		t.Error("Expected error for unknown group, got nil")
	}
}

// ---------------------------------------------------------------------
// 3. é›†æˆæµ‹è¯• (Integration Test)
// ---------------------------------------------------------------------

// TestGRPC_Integration å¯åŠ¨çœŸå®çš„ gRPC æœåŠ¡ç«¯ï¼Œå¹¶é€šè¿‡ Client è°ƒç”¨
func TestGRPC_Integration(t *testing.T) {
	// --- 1. å‡†å¤‡ç¯å¢ƒ ---
	addr := "localhost:9001" // æµ‹è¯•ç”¨çš„ç«¯å£
	groupName := "scores_rpc"

	// åˆå§‹åŒ– Group (è¿™æ˜¯ Server ç«¯å®é™…æŸ¥æ‰¾æ•°æ®çš„åœ°æ–¹)
	setupTestGroup(groupName)

	// --- 2. å¯åŠ¨ Server ---
	s := NewServer(addr)

	// åœ¨åç¨‹ä¸­å¯åŠ¨ Serverï¼Œå› ä¸º s.Start() æ˜¯é˜»å¡çš„
	go func() {
		// Start å†…éƒ¨ä¼šç›‘å¬ç«¯å£å¹¶é˜»å¡
		if err := s.Start(); err != nil {
			// æ³¨æ„ï¼šåœ¨å®é™…æµ‹è¯•ä¸­ï¼Œå¦‚æœ Server å…³é—­å¯èƒ½ä¼šå¯¼è‡´è¿™é‡ŒæŠ¥é”™ï¼Œå±äºæ­£å¸¸
			t.Logf("Server stopped: %v", err)
		}
	}()

	// ç­‰å¾…ä¸€å°ä¼šå„¿ï¼Œç¡®ä¿ Server å¯åŠ¨å®Œæ¯•
	time.Sleep(1 * time.Second)

	// --- 3. æ¨¡æ‹Ÿ Client ç«¯è°ƒç”¨ ---
	// æˆ‘ä»¬ç›´æ¥åˆ©ç”¨ grpcGetter (å®ƒæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ª Client å°è£…)
	// æˆ–è€…æ‰‹åŠ¨åˆ›å»º Client ä¹Ÿå¯ä»¥ã€‚è¿™é‡Œä¸ºäº†æµ‹è¯• grpcGetter ä»£ç ï¼Œç›´æ¥ç”¨å®ƒã€‚

	clientGetter := &grpcGetter{addr: addr}

	req := &pb.GetRequest{
		Group: groupName,
		Key:   "Jack", // å¯¹åº” mockDb ä¸­çš„ "589"
	}
	resp := &pb.GetResponse{}

	// è°ƒç”¨ Get (å†…éƒ¨ä¼š Dial -> RPC Call -> Receive)
	err := clientGetter.Get(req, resp)
	if err != nil {
		t.Fatalf("RPC Call failed: %v", err)
	}

	// --- 4. éªŒè¯ç»“æœ ---
	expected := "589"
	if string(resp.Value) != expected {
		t.Errorf("Integration test failed. Expected %s, got %s", expected, string(resp.Value))
	} else {
		t.Logf("Integration test success! Got value: %s", string(resp.Value))
	}
}
</file>

<file path="internal/singleflight/singleflight_test.go">
package singleflight

import (
	"sync"
	"testing"
	"time"
)

func TestSingleflightDo(t *testing.T) {
	var g Group

	count := 0
	fn := func() (interface{}, error) {
		count++
		time.Sleep(50 * time.Millisecond)
		return "ok", nil
	}

	const threads = 10
	var wg sync.WaitGroup
	wg.Add(threads)

	results := make([]interface{}, threads)

	for i := 0; i < threads; i++ {
		go func(i int) {
			defer wg.Done()
			v, _ := g.Do("same-key", fn)
			results[i] = v
		}(i)
	}

	wg.Wait()

	if count != 1 {
		t.Fatalf("expected fn to be called only once, but got %d", count)
	}

	for i := 0; i < threads; i++ {
		if results[i] != "ok" {
			t.Fatalf("unexpected result: %v", results[i])
		}
	}
}
</file>

<file path="internal/singleflight/singleflight.go">
package singleflight

import "sync"

// call è¡¨ç¤ºæ­£åœ¨è¿›è¡Œä¸­ï¼Œæˆ–å·²ç»ç»“æŸçš„è¯·æ±‚
type call struct {
	wg  sync.WaitGroup // ç­‰å¾…ç»„ï¼Œç”¨äºåŒæ­¥
	val interface{}    // è°ƒç”¨ç»“æœ
	err error          // è°ƒç”¨é”™è¯¯
}

// Group æ˜¯ singleflight çš„ä¸»æ•°æ®ç»“æ„ï¼Œç®¡ç†ä¸åŒkeyçš„è¯·æ±‚ï¼ˆcallï¼‰
type Group struct {
	mu sync.Mutex       // ä¿æŠ¤ m çš„å¹¶å‘è®¿é—®
	m  map[string]*call // key: è¯·æ±‚çš„é”®, value: å¯¹åº”çš„è°ƒç”¨ä¿¡æ¯
}

// Do é’ˆå¯¹ç›¸åŒçš„keyï¼Œæ— è®ºDoè¢«è°ƒç”¨å¤šå°‘æ¬¡ï¼Œå‡½æ•°fnéƒ½åªä¼šè¢«è°ƒç”¨ä¸€æ¬¡ï¼Œç­‰å¾…fnè°ƒç”¨ç»“æŸäº†ï¼Œè¿”å›è¿”å›å€¼æˆ–é”™è¯¯
func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) {
	// é”åªä¿æŠ¤mapçš„æ›´æ–°ï¼Œå®é™…ä¸šåŠ¡é€»è¾‘åœ¨é”å¤–æ‰§è¡Œ
	g.mu.Lock() // åŠ é”ï¼šä¿æŠ¤å¯¹ g.m çš„è®¿é—®
	// // 1. æ‡’åˆå§‹åŒ– map(ä¸è¦ä¸ºå¯èƒ½æ°¸è¿œä¸ä¼šè¢«ä½¿ç”¨çš„èµ„æºæå‰ä»˜è´¹ã€‚ç­‰åˆ°çœŸæ­£éœ€è¦æ—¶ï¼Œå†æŒ‰éœ€åˆ›å»ºã€‚)
	if g.m == nil {
		g.m = make(map[string]*call)
	}

	// å¦‚æœ key å¯¹åº”çš„è¯·æ±‚å·²ç»å­˜åœ¨ï¼Œåˆ™ç­‰å¾…å…¶å®Œæˆï¼Œå¹¶å…±äº«ç»“æœ
	if c, exist := g.m[key]; exist {
		g.mu.Unlock() //  è§£é”ï¼šæ£€æŸ¥å®Œæˆï¼Œé‡Šæ”¾é”
		c.wg.Wait()   // ç­‰å¾…æ­£åœ¨è¿›è¡Œçš„è¯·æ±‚å®Œæˆ
		return c.val, c.err
	}

	// å¦‚æœ key å¯¹åº”çš„è¯·æ±‚ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„ call
	c := new(call)
	c.wg.Add(1)  // å‘èµ·è¯·æ±‚å‰åŠ é”ï¼Œä»–å¹¶å‘è¯·æ±‚c.wg.Wait() ç­‰å¾…ä»»åŠ¡å®Œæˆ
	g.m[key] = c // æ·»åŠ åˆ° map ä¸­ï¼Œè¡¨ç¤º key æ­£åœ¨å¤„ç†
	g.mu.Unlock()

	// æ‰§è¡Œè¯·æ±‚ï¼ˆå¦‚æŸ¥è¯¢æ•°æ®åº“/è¿œç¨‹èŠ‚ç‚¹ï¼‰
	c.val, c.err = fn()
	c.wg.Done() // è¯·æ±‚å®Œæˆ,è®¡æ•°å™¨ -1

	g.mu.Lock()
	delete(g.m, key) // æ›´æ–° g.mï¼Œç§»é™¤ key
	g.mu.Unlock()

	return c.val, c.err
}
</file>

<file path="scripts/run.sh">
#!/bin/bash

# é‡åˆ°é”™è¯¯ç«‹å³é€€å‡º
set -e

# é¡¹ç›®æ ¹ç›®å½•
ROOT_DIR=$(pwd)
SERVER_BIN="./bin/server"
CLIENT_BIN="./bin/client"

# 1. ç¼–è¯‘ä»£ç 
echo "Building server..."
go build -o $SERVER_BIN ./cmd/server
echo "Building client..."
go build -o $CLIENT_BIN ./cmd/client

# 2. æ£€æŸ¥ Etcd æ˜¯å¦è¿è¡Œ
echo "Checking Etcd..."
if ! pgrep -x "etcd" > /dev/null && ! docker ps | grep "etcd" > /dev/null; then
    echo "Etcd is not running. Starting local etcd via docker..."
    docker run -d --rm --name etcd-server \
    -p 2379:2379 \
    -e ALLOW_NONE_AUTHENTICATION=yes \
    bitnami/etcd:latest
    sleep 3 # ç­‰å¾… etcd å¯åŠ¨
else
    echo "Etcd is running."
fi

# 3. æ¸…ç†æ—§çš„ Server è¿›ç¨‹
echo "Cleaning up old server processes..."
trap "kill 0" EXIT # è„šæœ¬é€€å‡ºæ—¶æ€æ­»æ‰€æœ‰å­è¿›ç¨‹

# 4. å¯åŠ¨é›†ç¾¤ (3ä¸ªèŠ‚ç‚¹)
# æ³¨æ„ï¼šè¿™éœ€è¦ä½ çš„ main.go æ”¯æŒä»é…ç½®æ–‡ä»¶è¯»å–ï¼Œæˆ–è€…æ”¯æŒè¿™é‡Œä¼ å…¥çš„å‘½ä»¤è¡Œå‚æ•°
# è¿™é‡Œå‡è®¾ main.go ä»ç„¶ä½¿ç”¨ flag æ¥æ”¶å‚æ•°
echo "Starting cluster nodes..."

# èŠ‚ç‚¹1 (ç«¯å£ 8001)
$SERVER_BIN -port=8001 -etcd=localhost:2379 -group=scores &
PID1=$!
echo "Node 1 started (PID: $PID1, Port: 8001)"

# èŠ‚ç‚¹2 (ç«¯å£ 8002)
$SERVER_BIN -port=8002 -etcd=localhost:2379 -group=scores &
PID2=$!
echo "Node 2 started (PID: $PID2, Port: 8002)"

# èŠ‚ç‚¹3 (ç«¯å£ 8003)
$SERVER_BIN -port=8003 -etcd=localhost:2379 -group=scores &
PID3=$!
echo "Node 3 started (PID: $PID3, Port: 8003)"

sleep 2
echo "Cluster started successfully!"
echo "Press Ctrl+C to stop the cluster..."

# 5. ä¿æŒè¿è¡Œï¼Œç›´åˆ°ç”¨æˆ·æŒ‰ä¸‹ Ctrl+C
wait
</file>

<file path="test/benchmark_test.go">
package test

import (
	"context"
	"flag"
	"log"
	"math/rand"
	"testing"
	"time"

	pb "DistributedCache/api/cachepb" // å¼•ç”¨ç”Ÿæˆçš„ gRPC ä»£ç 

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

var (
	serverAddr = flag.String("addr", "localhost:8001", "The address of the cache server")
)

// client åŒ…è£… gRPC å®¢æˆ·ç«¯
type client struct {
	pb.GroupCacheClient
	conn *grpc.ClientConn
}

func newClient(addr string) (*client, error) {
	conn, err := grpc.Dial(addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return nil, err
	}
	c := pb.NewGroupCacheClient(conn)
	return &client{GroupCacheClient: c, conn: conn}, nil
}

func (c *client) Close() {
	c.conn.Close()
}

// BenchmarkGet æµ‹è¯• Get æ¥å£çš„ååé‡
// è¿è¡Œæ–¹å¼: go test -v -bench=BenchmarkGet -benchmem -args -addr=localhost:8001
func BenchmarkGet(b *testing.B) {
	// 1. åˆå§‹åŒ–å®¢æˆ·ç«¯è¿æ¥
	cli, err := newClient(*serverAddr)
	if err != nil {
		b.Fatalf("Failed to create client: %v", err)
	}
	defer cli.Close()

	groupName := "scores"
	// å¯é€‰ï¼šé¢„å…ˆå®šä¹‰ä¸€äº›æµ‹è¯•ç”¨çš„ key
	keys := []string{"Tom", "Jack", "Sam", "Amy", "Bob"}

	// 2. å¹¶è¡Œæµ‹è¯•
	b.ResetTimer()

	// æ³¨æ„è¿™é‡Œï¼šæˆ‘ä»¬å°† testing.PB å‚æ•°å‘½åä¸º pï¼Œé¿å…ä¸åŒ…å pb å†²çª
	b.RunParallel(func(p *testing.PB) {
		for p.Next() {
			// éšæœºé€‰æ‹©ä¸€ä¸ª Key
			key := keys[rand.Intn(len(keys))]

			// æ„é€ è¯·æ±‚
			req := &pb.GetRequest{
				Group: groupName,
				Key:   key,
			}

			// å‘é€ RPC è¯·æ±‚
			_, err := cli.Get(context.Background(), req)
			if err != nil {
				// åœ¨ Benchmark ä¸­é€šå¸¸ä¸ Fatalï¼Œé€šè¿‡æ—¥å¿—è®°å½•é”™è¯¯ç‡å³å¯
				// æˆ–è€…å¿½ç•¥éå…³é”®é”™è¯¯ï¼Œä¸“æ³¨äºååé‡
				// log.Printf("rpc error: %v", err)
			}
		}
	})
}

// TestMain ç”¨äºè§£æ flags
func TestMain(m *testing.M) {
	flag.Parse()
	rand.Seed(time.Now().UnixNano())
	log.Printf("Starting benchmark against %s", *serverAddr)
	m.Run()
}
</file>

<file path=".cspell.json">
{
    "version": "0.2",
    "words": [
        "protoc",
        "protobuf",
        "grpc",
        "cachepb"
    ],
    "ignorePaths": [
        "**/*.pb.go",
        "**/*_grpc.pb.go",
        "**/*_pb.go"
    ]
}
</file>

<file path="config.json">
{
  "addr": "localhost:8001",
  "etcd_addrs": [
    "localhost:2379"
  ],
  "cache_size": 1048576,
  "cache_policy": "lfu",
  "service_name": "distributed-cache/nodes"
}
</file>

<file path="cmd/server/main.go">
package main

import (
	"flag"
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"

	"DistributedCache/config"
	"DistributedCache/internal/discovery"
	"DistributedCache/internal/group"
	"DistributedCache/internal/server"
)

// æ¨¡æ‹Ÿæ•°æ®åº“
var mockDB = map[string]string{
	"Tom":  "630",
	"Jack": "589",
	"Sam":  "567",
	"Amy":  "985",
	"Bob":  "211",
}

func main() {
	// 1. å°è¯•åŠ è½½é…ç½®æ–‡ä»¶
	// é»˜è®¤è¯»å–å½“å‰ç›®å½•ä¸‹çš„ config.json
	// å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼ŒLoadConfig ä¼šè¿”å›é»˜è®¤é…ç½®ï¼Œä¸ä¼šæŠ¥é”™
	cfg, err := config.LoadConfig("config.json")
	if err != nil {
		// å¦‚æœæ˜¯ JSON æ ¼å¼é”™è¯¯ç­‰ä¸¥é‡é”™è¯¯ï¼Œåˆ™é€šè¿‡æ—¥å¿—è­¦å‘Šï¼Œä½†ä¾ç„¶ä½¿ç”¨é»˜è®¤å€¼ç»§ç»­è¿è¡Œ
		log.Printf("[Config] Failed to load config.json: %v, using defaults.", err)
		cfg = config.DefaultConfig()
	}

	// 2. è§£æå‘½ä»¤è¡Œå‚æ•°
	// ç­–ç•¥ï¼šä½¿ç”¨ Config ä¸­çš„å€¼ä½œä¸º Flag çš„é»˜è®¤å€¼ã€‚
	// è¿™æ ·ï¼šå‘½ä»¤è¡Œ > é…ç½®æ–‡ä»¶ > ä»£ç ç¡¬ç¼–ç é»˜è®¤å€¼

	var (
		port        int
		api         bool
		etcdAddrs   string
		groupName   string
		cacheSize   int64
		cachePolicy string
	)

	// ä» cfg.Addr ("localhost:8001") ä¸­è§£æå‡ºç«¯å£ä½œä¸ºé»˜è®¤ç«¯å£
	defaultPort := 8001
	if _, pStr, err := net.SplitHostPort(cfg.Addr); err == nil {
		if p, err := strconv.Atoi(pStr); err == nil {
			defaultPort = p
		}
	}

	flag.IntVar(&port, "port", defaultPort, "server port")
	flag.BoolVar(&api, "api", false, "Start a api server")
	// å°† config ä¸­çš„å­—ç¬¦ä¸²æ•°ç»„æ‹¼æ¥æˆé€—å·åˆ†éš”å­—ç¬¦ä¸²ï¼Œä½œä¸º flag é»˜è®¤å€¼
	flag.StringVar(&etcdAddrs, "etcd", strings.Join(cfg.EtcdAddrs, ","), "Etcd endpoints, separated by comma")
	flag.StringVar(&groupName, "group", "scores", "Cache group name")
	// å¢åŠ ç¼“å­˜é…ç½®çš„ flagï¼Œå…è®¸é€šè¿‡å‘½ä»¤è¡Œè¦†ç›– config.json
	flag.Int64Var(&cacheSize, "cache_size", cfg.CacheSize, "Max cache size in bytes")
	flag.StringVar(&cachePolicy, "cache_policy", cfg.CachePolicy, "Cache replacement policy (lru, lfu, fifo)")

	flag.Parse() // â† è§£æå‘½ä»¤è¡Œï¼Œå¦‚æœæœ‰ä¼ å‚ï¼Œä¼šè¦†ç›–ä¸Šé¢çš„é»˜è®¤å€¼

	// 3. åˆå§‹åŒ–æ ¸å¿ƒç»„ä»¶ï¼šGroup (ç¼“å­˜å‘½åç©ºé—´)
	// å®šä¹‰å½“ç¼“å­˜æœªå‘½ä¸­æ—¶å¦‚ä½•å›æºè·å–æ•°æ®
	getter := group.GetterFunc(func(key string) ([]byte, error) {
		log.Printf("[SlowDB] Searching key: %s", key)
		if v, ok := mockDB[key]; ok {
			return []byte(v), nil
		}
		return nil, fmt.Errorf("%s not exist", key)
	})

	// åˆ›å»º Group
	// ä½¿ç”¨é…ç½®ä¸­çš„ cacheSize å’Œ cachePolicy
	g := group.NewGroup(groupName, cacheSize, cachePolicy, getter)
	log.Printf("Group [%s] initialized. Policy: %s, Size: %d bytes", groupName, cachePolicy, cacheSize)

	// 4. åˆå§‹åŒ– gRPC Server
	// ç»„è£…åœ°å€
	addr := fmt.Sprintf("localhost:%d", port)
	svr := server.NewServer(addr)

	// å°† Server æ³¨å†Œä¸º Group çš„ PeerPicker
	g.RegisterPeers(svr)

	// 5. Etcd æœåŠ¡å‘ç°ä¸æ³¨å†Œ
	// å°† flag è§£æå‡ºæ¥çš„ etcdAddrs (é€—å·åˆ†éš”) è½¬å› slice
	etcdEndpoints := strings.Split(etcdAddrs, ",")
	// ä½¿ç”¨ config ä¸­çš„ ServiceName (é€šå¸¸æ˜¯å‰ç¼€ï¼Œå¦‚ "distributed-cache/nodes")
	servicePrefix := cfg.ServiceName

	// A. æœåŠ¡æ³¨å†Œ (Register)
	reg, err := discovery.NewRegister(etcdEndpoints)
	if err != nil {
		log.Fatalf("Failed to create etcd register: %v", err)
	}
	defer reg.Stop()

	// æ³¨å†Œå¹¶ç»´æŒç§Ÿçº¦ (TTL 10ç§’)
	if err := reg.Register(servicePrefix, addr, 10); err != nil {
		log.Fatalf("Failed to register service: %v", err)
	}
	log.Printf("Node registered to Etcd: %s (Prefix: %s)", addr, servicePrefix)

	// B. æœåŠ¡å‘ç° (Discovery)
	disc, err := discovery.NewDiscovery(etcdEndpoints)
	if err != nil {
		log.Fatalf("Failed to create etcd discovery: %v", err)
	}
	defer disc.Stop()

	// ç›‘å¬èŠ‚ç‚¹å˜åŒ–
	err = disc.WatchService(servicePrefix, func(peers []string) {
		svr.SetPeers(peers...)
		log.Printf("Cluster peers updated: %v", peers)
	})
	if err != nil {
		log.Fatalf("Failed to watch service: %v", err)
	}

	// 6. å¯åŠ¨ gRPC æœåŠ¡
	go func() {
		log.Printf("Server is running at %s...", addr)
		if err := svr.Start(); err != nil {
			log.Fatalf("Failed to start server: %v", err)
		}
	}()

	// 7. ä¼˜é›…é€€å‡º
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Println("Server is shutting down...")
}
</file>

<file path="internal/cache/cache_test.go">
package cache

import (
	"DistributedCache/internal/byteview"
	"DistributedCache/internal/core/policy"
	"testing"
)

func TestCacheBasic(t *testing.T) {
	c := NewCache(100, "lru", nil)

	v1 := byteview.New([]byte("hello"))
	c.Add("k1", v1)

	val, ok := c.Get("k1")
	if !ok {
		t.Fatalf("expected k1 exist")
	}
	if string(val.ByteSlice()) != "hello" {
		t.Fatalf("unexpected value: %s", val.ByteSlice())
	}
}

// æµ‹è¯•æ·˜æ±°ç­–ç•¥æ˜¯å¦è¢«è°ƒç”¨
func TestCacheEviction(t *testing.T) {
	evicted := ""
	onEvicted := func(key string, value policy.Value) {
		evicted = key
	}

	c := NewCache(10, "lru", onEvicted)

	c.Add("k1", byteview.New([]byte("12345")))
	c.Add("k2", byteview.New([]byte("12345"))) // è¶…è¿‡å®¹é‡è§¦å‘æ·˜æ±°

	if evicted == "" {
		t.Fatalf("Eviction expected but did not happen")
	}
}
</file>

<file path="internal/cache/cache.go">
package cache

// æœ¬åœ°å†…å­˜ + å¹¶å‘æ§åˆ¶
import (
	"DistributedCache/internal/byteview"
	"DistributedCache/internal/core/fifo"
	"DistributedCache/internal/core/lfu"
	"DistributedCache/internal/core/lru"
	"DistributedCache/internal/core/policy"
	"sync"
)

// cache æ˜¯å¯¹åº•å±‚ç¼“å­˜ç­–ç•¥ç®—æ³•çš„å¹¶å‘å®‰å…¨å°è£…
// å®ƒä¸åº”è¯¥è¢«å¤–éƒ¨ç›´æ¥ä½¿ç”¨ï¼Œè€Œæ˜¯ä½œä¸º Group çš„ç»„ä»¶
// å¼€å¤´å¤§å†™å°±æ˜¯å¯å¯¼å‡ºï¼ˆå…¬æœ‰ï¼‰,å°å†™æ˜¯ä¸å¯å¯¼å‡º
type Cache struct {
	mu         sync.RWMutex          // è¯»å†™é”:å…è®¸å¤šä¸ªè¯»ï¼Œä½†å†™æ“ä½œäº’æ–¥
	policy     policy.EvictionPolicy // æ ¸å¿ƒæ¥å£ï¼Œæ”¯æŒå¤šæ€
	cacheBytes int64                 // å…è®¸ä½¿ç”¨çš„æœ€å¤§å†…å­˜
	policyType string                // ç­–ç•¥ç±»å‹: "lru", "fifo", "lfu"
	onEvicted  func(string, policy.Value)
}

// newCache åˆ›å»ºä¸€ä¸ªæ–°çš„å¹¶å‘ç¼“å­˜å®ä¾‹
func NewCache(cacheBytes int64, policyType string, onEvicted func(string, policy.Value)) *Cache {
	return &Cache{
		cacheBytes: cacheBytes,
		policyType: policyType,
		onEvicted:  onEvicted,
	}
}

// add å†™å…¥ç¼“å­˜ï¼ˆå¹¶å‘å®‰å…¨ï¼‰
func (c *Cache) Add(key string, val byteview.Byteview) {
	c.mu.Lock()
	defer c.mu.Unlock()

	// æ‡’åŠ è½½ï¼šåªæœ‰åœ¨ç¬¬ä¸€æ¬¡ add æ—¶æ‰åˆå§‹åŒ–åº•å±‚æ•°æ®ç»“æ„
	// è¿™æ ·å¯ä»¥é¿å…åˆ›å»ºäº† Group ä½†è¿˜æ²¡å­˜æ•°æ®æ—¶å°±å ç”¨äº†å†…å­˜
	if c.policy == nil {
		c.policy = createPolicy(c.policyType, c.cacheBytes, c.onEvicted)
	}
	c.policy.Add(key, val)
}

// get è¯»å–ç¼“å­˜ï¼ˆå¹¶å‘å®‰å…¨ï¼‰
func (c *Cache) Get(key string) (value byteview.Byteview, ok bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	if c.policy == nil {
		return
	}

	if v, exist := c.policy.Get(key); exist {
		// è¿™é‡Œçš„ v æ˜¯ policy.Value æ¥å£ï¼Œéœ€è¦æ–­è¨€å› byteview.ByteView
		return v.(byteview.Byteview), true
	}
	return
}

// createPolicy å·¥å‚æ–¹æ³•ï¼šæ ¹æ®å­—ç¬¦ä¸²åç§°å®ä¾‹åŒ–å¯¹åº”çš„æ·˜æ±°ç­–ç•¥
func createPolicy(policyType string, maxBytes int64, onEvicted func(string, policy.Value)) policy.EvictionPolicy {
	switch policyType {
	case "fifo":
		return fifo.New(maxBytes, onEvicted)
	case "lfu":
		return lfu.New(maxBytes, onEvicted)
	case "lru":
		// é»˜è®¤ä½¿ç”¨ LRU
		return lru.New(maxBytes, onEvicted)
	default:
		return lru.New(maxBytes, onEvicted)
	}
}
</file>

<file path="internal/core/fifo/fifo_test.go">
package fifo

import (
	"DistributedCache/internal/core/policy"
	"testing"
)

// ---- mock value type for testing ----
// cspell:ignore nbytes
// é¡¹ç›®ä¸­çš„ Value è¦æ±‚å®ç° Len() intï¼Œå› æ­¤è¿™é‡Œç”¨ç®€å•çš„ String æ¥ mock
type String string

func (s String) Len() int {
	return len(s)
}

// åŸºç¡€æµ‹è¯•ï¼šAdd + Get
func TestCacheGet(t *testing.T) {
	fifo := New(0, nil)

	fifo.Add("key1", String("12345"))

	value, ok := fifo.Get("key1")
	if !ok {
		t.Fatalf("expected key1 exists")
	}
	if string(value.(String)) != "12345" {
		t.Fatalf("expected 12345, but got %v", value)
	}

	if _, ok := fifo.Get("not_exist"); ok {
		t.Fatalf("expected miss for not_exist")
	}
}

// æ›´æ–° key æ—¶æ˜¯å¦æ›¿æ¢ value + nbytes æ˜¯å¦æ­£ç¡®æ›´æ–°
func TestCacheUpdate(t *testing.T) {
	fifo := New(0, nil)

	fifo.Add("k", String("111"))
	if fifo.nbytes != int64(len("k")+len("111")) {
		t.Fatalf("unexpected nbytes, got %d", fifo.nbytes)
	}

	fifo.Add("k", String("22"))
	if fifo.nbytes != int64(len("k")+len("22")) { // æ ¹æ®æ›´æ–°è®¡ç®—
		t.Fatalf("update nbytes mismatch, got %d", fifo.nbytes)
	}

	val, _ := fifo.Get("k")
	if string(val.(String)) != "22" {
		t.Fatalf("update value mismatch, got %v", val)
	}
}

// æµ‹è¯• maxBytes æ§åˆ¶å¯¼è‡´çš„æ·˜æ±°ï¼ˆRemoveOldestï¼‰
func TestCacheEviction(t *testing.T) {
	evicted := make([]string, 0)

	// æ³¨å†Œå›è°ƒå‡½æ•°æ¥ç›‘æµ‹æ˜¯å¦å‘ç”Ÿæ·˜æ±°
	onEvicted := func(key string, value policy.Value) {
		evicted = append(evicted, key)
	}

	// åªå…è®¸å­˜ä¸‹ key1 å’Œ key2 çš„ç©ºé—´
	capacity := int64(len("key1") + len("111") + len("key2") + len("222"))
	fifo := New(capacity, onEvicted)

	// add key1, key2
	fifo.Add("key1", String("111"))
	fifo.Add("key2", String("222"))

	// æ·»åŠ  key3 ä¼šå¯¼è‡´ key1 è¢«æ·˜æ±°ï¼ˆæœ€å…ˆåŠ å…¥ï¼‰
	fifo.Add("key3", String("333"))

	if _, ok := fifo.Get("key1"); ok {
		t.Fatalf("expected key1 to be evicted")
	}

	if len(evicted) == 0 || evicted[0] != "key1" {
		t.Fatalf("onEvicted not triggered or wrong key, got %v", evicted)
	}
}

// æµ‹è¯• Remove(key)
func TestCacheRemove(t *testing.T) {
	lru := New(0, nil)

	lru.Add("a", String("1"))
	lru.Add("b", String("2"))

	lru.Remove("a")

	if _, ok := lru.Get("a"); ok {
		t.Fatalf("expected a to be removed")
	}

	if lru.Len() != 1 {
		t.Fatalf("expected cache len = 1, got %d", lru.Len())
	}
}

// ---- Test: Update does not change order ----
func TestUpdateDoesNotMove(t *testing.T) {
	// è®¾ç½®åˆšå¥½èƒ½å®¹çº³3ä¸ªå…ƒç´ çš„å®¹é‡
	f := New(9, nil) // æ¯ä¸ªå…ƒç´ : 2(key) + 1(value) = 3å­—èŠ‚ Ã— 3ä¸ª = 9å­—èŠ‚

	f.Add("k1", String("a")) // 2+1=3å­—èŠ‚
	f.Add("k2", String("b")) // 2+1=3å­—èŠ‚ï¼Œæ€»6
	f.Add("k3", String("c")) // 2+1=3å­—èŠ‚ï¼Œæ€»9

	// è®°å½•æ·˜æ±°é¡ºåº
	var evictedOrder []string
	f.OnEvicted = func(key string, value policy.Value) {
		evictedOrder = append(evictedOrder, key)
	}

	// æ›´æ–°k2ï¼Œä¸åº”è¯¥æ”¹å˜å®ƒåœ¨é˜Ÿåˆ—ä¸­çš„ä½ç½®
	f.Add("k2", String("b")) // å¤§å°ä¸å˜ï¼Œåªæ˜¯æ›´æ–°

	// æ·»åŠ ç¬¬4ä¸ªå…ƒç´ ï¼Œåº”è¯¥æ·˜æ±°k1ï¼ˆæœ€æ—©åŠ å…¥çš„ï¼‰
	f.Add("k4", String("d")) // è§¦å‘æ·˜æ±°

	// éªŒè¯æ·˜æ±°é¡ºåº
	if len(evictedOrder) != 1 || evictedOrder[0] != "k1" {
		t.Fatalf("expected k1 evicted first, got %v", evictedOrder)
	}

	// éªŒè¯k2ä»ç„¶å­˜åœ¨ï¼ˆè¯æ˜æ›´æ–°æ²¡æœ‰æ”¹å˜ä½ç½®ï¼‰
	if _, ok := f.Get("k2"); !ok {
		t.Fatal("k2 should still exist after update")
	}
}
</file>

<file path="internal/core/fifo/fifo.go">
package fifo

import (
	"DistributedCache/internal/core/policy"
	"container/list"
)

// Cache æ˜¯ä¸€ä¸ªFIFO ç¼“å­˜
// cspell:ignore nbytes
type Cache struct {
	maxBytes  int64                                // å…è®¸ä½¿ç”¨çš„æœ€å¤§å†…å­˜
	nbytes    int64                                // å½“å‰å·²ä½¿ç”¨çš„å†…å­˜
	ll        *list.List                           // åŒå‘é“¾è¡¨
	cache     map[string]*list.Element             //é”®æ˜ å°„åˆ°é“¾è¡¨èŠ‚ç‚¹(list.Element:next, prev *Element,Value)
	OnEvicted func(key string, value policy.Value) // æŸæ¡è®°å½•è¢«ç§»é™¤æ—¶çš„å›è°ƒ,æœ‰äº›ç¼“å­˜å€¼å¯èƒ½æŒæœ‰èµ„æºï¼ˆæ–‡ä»¶ã€è¿æ¥ç­‰ï¼‰ï¼Œéœ€è¦æ­£ç¡®é‡Šæ”¾
}

type entry struct {
	key   string
	value policy.Value
}

func New(maxBytes int64, onEvicted func(string, policy.Value)) *Cache {
	return &Cache{
		maxBytes:  maxBytes,
		ll:        list.New(),
		cache:     make(map[string]*list.Element),
		OnEvicted: onEvicted,
	}
}

func (c *Cache) Get(key string) (val policy.Value, ok bool) {
	if ele, exist := c.cache[key]; exist {
		// FIFO è¿™é‡Œä¸éœ€è¦ MoveToFrontï¼Œå› ä¸ºè®¿é—®ä¸æ”¹å˜â€œå…ˆå…¥â€çš„é¡ºåº
		kv := ele.Value.(*entry)
		return kv.value, true
	}
	return
}

func (c *Cache) Add(key string, val policy.Value) {
	if ele, exist := c.cache[key]; exist {
		// æ›´æ–°å€¼ï¼Œä½ç½®ä¸å˜ï¼ˆæˆ–è€…ä¹Ÿå¯ä»¥çœ‹ä½œæ–°æ’å…¥ç§»åˆ°é˜Ÿå°¾ï¼Œå–å†³äºå…·ä½“å®šä¹‰ï¼Œé€šå¸¸ FIFO æ›´æ–°ä¸æ”¹å˜æ·˜æ±°åºï¼‰
		kv := ele.Value.(*entry)
		c.nbytes = c.nbytes - int64(kv.value.Len()) + int64(val.Len())
		kv.value = val
	} else {
		ele := c.ll.PushBack(&entry{key, val}) //æ–°å¢æ”¾é˜Ÿå°¾
		c.cache[key] = ele
		c.nbytes = c.nbytes + int64(val.Len()) + int64(len(key))
	}

	for c.maxBytes != 0 && c.maxBytes < c.nbytes {
		c.RemoveOldest()
	}
}

func (c *Cache) RemoveOldest() {
	ele := c.ll.Front()
	if ele != nil {
		c.ll.Remove(ele)
		kv := ele.Value.(*entry)
		delete(c.cache, kv.key)
		c.nbytes = c.nbytes - int64(len(kv.key)) - int64(kv.value.Len())
		if c.OnEvicted != nil {
			c.OnEvicted(kv.key, kv.value)
		}
	}
}

func (c *Cache) Remove(key string) {
	if ele, exist := c.cache[key]; exist {
		c.ll.Remove(ele)
		kv := ele.Value.(*entry)
		delete(c.cache, kv.key)
		c.nbytes = c.nbytes - int64(len(kv.key)) - int64(kv.value.Len())
		if c.OnEvicted != nil {
			c.OnEvicted(kv.key, kv.value)
		}
	}
}

func (c *Cache) Len() int {
	return c.ll.Len()
}
</file>

<file path="internal/core/lfu/lfu.go">
package lfu

import (
	"DistributedCache/internal/core/policy"
	"container/heap"
)

// æœ€å°å †çš„æ’åºä»é˜Ÿå¤´åˆ°é˜Ÿå°¾æ˜¯ä»å°åˆ°å¤§çš„
// cspell:ignore nbytes
type Cache struct {
	maxBytes  int64
	nbytes    int64
	pq        *priorityQueue // ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰ï¼ŒæŒ‰é¢‘ç‡æ’åº
	cache     map[string]*entry
	seq       int64                                // å…¨å±€é€’å¢åºå·ï¼Œæ¨¡æ‹Ÿæ—¶é—´
	OnEvicted func(key string, value policy.Value) // æ·˜æ±°å›è°ƒå‡½æ•°
}

type entry struct {
	key   string
	value policy.Value
	freq  int   // è®¿é—®é¢‘ç‡
	index int   // åœ¨å †çš„ç´¢å¼•
	ts    int64 // æ—¶é—´æˆ³/åºå·ï¼Œç”¨äºé¢‘ç‡ç›¸ç­‰æ—¶æŒ‰è®¿é—®æ—¶é—´æ·˜æ±°
}

func New(maxBytes int64, onEvicted func(string, policy.Value)) *Cache {
	return &Cache{
		maxBytes:  maxBytes,
		pq:        &priorityQueue{},
		cache:     map[string]*entry{},
		OnEvicted: onEvicted,
	}
}

func (c *Cache) Get(key string) (val policy.Value, ok bool) {
	if ele, exist := c.cache[key]; exist {
		c.update(ele, ele.value) // å¢åŠ é¢‘ç‡ï¼Œæ›´æ–°æ—¶é—´
		return ele.value, true
	}
	return
}

func (c *Cache) Add(key string, val policy.Value) {
	if ele, exist := c.cache[key]; exist {
		c.nbytes = c.nbytes - int64(ele.value.Len()) + int64(val.Len())
		c.update(ele, val)
	} else {
		c.seq++                                                 // æ–°å¢ä¹Ÿç®—ä¸€æ¬¡è®¿é—®ï¼Œåºå·å¢åŠ 
		ele := &entry{key: key, value: val, freq: 1, ts: c.seq} // æ–°å¢å…ƒç´ é¢‘ç‡é€šå¸¸åˆå§‹åŒ–ä¸º1
		c.cache[key] = ele
		heap.Push(c.pq, ele)
		c.nbytes = c.nbytes + int64(len(key)) + int64(val.Len())
	}

	// å¾ªç¯æ·˜æ±°ç›´åˆ°å®¹é‡æ»¡è¶³
	for c.maxBytes != 0 && c.maxBytes < c.nbytes {
		c.RemoveOldest()
	}
}

// update å†…éƒ¨å¸®åŠ©å‡½æ•°ï¼šæ›´æ–°å€¼ã€å¢åŠ é¢‘ç‡ã€æ›´æ–°æ—¶é—´æˆ³ã€è°ƒæ•´å †
func (c *Cache) update(ele *entry, val policy.Value) {
	ele.value = val
	ele.freq++
	c.seq++
	ele.ts = c.seq // æ›´æ–°ä¸ºæœ€æ–°æ“ä½œåºå·
	heap.Fix(c.pq, ele.index)
}

func (c *Cache) RemoveOldest() {
	if c.pq.Len() == 0 {
		return
	}
	ele := heap.Pop(c.pq).(*entry) // å¼¹å‡ºé¢‘ç‡æœ€ä½çš„
	delete(c.cache, ele.key)
	c.nbytes = c.nbytes - int64(len(ele.key)) - int64(ele.value.Len())
	if c.OnEvicted != nil {
		c.OnEvicted(ele.key, ele.value)
	}
}

func (c *Cache) Remove(key string) {
	if ele, exist := c.cache[key]; exist {
		heap.Remove(c.pq, ele.index)
		delete(c.cache, ele.key)
		c.nbytes = c.nbytes - int64(len(ele.key)) - int64(ele.value.Len())
		if c.OnEvicted != nil {
			c.OnEvicted(ele.key, ele.value)
		}
	}
}

func (c *Cache) Len() int {
	return c.pq.Len()
}

// priorityQueue å®ç° heap.Interface
type priorityQueue []*entry

func (pq priorityQueue) Len() int {
	return len(pq)
}

func (pq priorityQueue) Less(i, j int) bool {
	return pq[i].freq < pq[j].freq
}

func (pq priorityQueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
	pq[i].index = j
	pq[j].index = i
}

func (pq *priorityQueue) Push(x interface{}) {
	n := len(*pq)
	item := x.(*entry)
	item.index = n
	*pq = append(*pq, item)
}

// å½“è°ƒç”¨ heap.Pop(pq)æ—¶ï¼Œheap.Pop()ä¼šå…ˆå°†å †é¡¶å…ƒç´ ï¼ˆé¢‘ç‡æœ€å°ï¼‰ä¸æœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢
// ç„¶åè°ƒç”¨ pq.Pop() å–å‡ºæœ€åä¸€ä¸ªå…ƒç´ 
// é‡æ–°å †åŒ–ï¼Œç»´æŠ¤å †æ€§è´¨
func (pq *priorityQueue) Pop() interface{} {
	old := *pq
	n := len(old)
	item := old[n-1]
	item.index = -1
	*pq = old[:n-1]
	return item
}
</file>

<file path="internal/core/lru/lru_test.go">
package lru

//  Go æµ‹è¯•æ¡†æ¶ä¼šä¸ºæ¯ä¸ªæµ‹è¯•å‡½æ•°åˆ›å»ºæ–°çš„æµ‹è¯•ç¯å¢ƒ
import (
	"DistributedCache/internal/core/policy"
	"testing"
)

type String string

// ---- mock value type for testing ----
// cspell:ignore nbytes
// é¡¹ç›®ä¸­çš„ Value è¦æ±‚å®ç° Len() intï¼Œå› æ­¤è¿™é‡Œç”¨ç®€å•çš„ String æ¥ mock
func (s String) Len() int {
	return len(s)
}

// åŸºç¡€æµ‹è¯•ï¼šAdd + Get
func TestGet(t *testing.T) {
	lru := New(int64(0), nil) // å½“ maxBytes = 0æ—¶ï¼Œæ„å‘³ç€ç¼“å­˜æ²¡æœ‰å®¹é‡é™åˆ¶
	lru.Add("key1", String("1234"))

	val, ok := lru.Get("key1")
	if !ok {
		t.Fatalf("expected key1 exists")
	}
	if string(val.(String)) != "1234" {
		t.Fatalf("expected 1234,but got %v", val)
	}

	if _, ok := lru.Get("not_exist"); ok {
		t.Fatalf("expected miss for not_exist")
	}
}

// æ›´æ–° key æ—¶æ˜¯å¦æ›¿æ¢ value + nbytes æ˜¯å¦æ­£ç¡®æ›´æ–°
func TestUpdate(t *testing.T) {
	lru := New(int64(0), nil)

	lru.Add("key1", String("111"))
	if lru.nbytes != int64(len("key1")+len("111")) {
		t.Fatalf("unexpected nbytes, got %d", lru.nbytes)
	}

	lru.Add("key1", String("22"))
	if lru.nbytes != int64(len("key1")+len("22")) { // æ ¹æ®æ›´æ–°è®¡ç®—
		t.Fatalf("update nbytes mismatch, got %d", lru.nbytes)
	}

	val, _ := lru.Get("key1")
	if string(val.(String)) != "22" {
		t.Fatalf("update value mismatch, got %v", val)
	}
}

// æµ‹è¯• maxBytes æ§åˆ¶å¯¼è‡´çš„æ·˜æ±°ï¼ˆRemoveOldestï¼‰
func TestEviction(t *testing.T) {
	evicted := make([]string, 0)

	// æ³¨å†Œå›è°ƒå‡½æ•°æ¥ç›‘æ§æ˜¯å¦å‘ç”Ÿæ·˜æ±°
	onEvicted := func(key string, value policy.Value) {
		evicted = append(evicted, key) // è®°å½•ç§»é™¤çš„key
	}

	// åªå…è®¸å­˜ä¸‹ key1 å’Œ key2 çš„ç©ºé—´
	capacity := int64(len("key1") + len("111") + len("key2") + len("222"))
	lru := New(capacity, onEvicted)

	// add key1,key2
	lru.Add("key1", String("111"))
	lru.Add("key2", String("222"))

	// æ·»åŠ  key3 ä¼šå¯¼è‡´ key1 è¢«æ·˜æ±°ï¼ˆæœ€ä¹…æœªä½¿ç”¨ï¼‰
	lru.Add("key3", String("333"))

	if _, ok := lru.Get("key1"); ok {
		t.Fatalf("expected key1 to be evicted")
	}

	if len(evicted) == 0 || evicted[0] != "key1" {
		t.Fatalf("onEvicted not triggered or wrong key, got %v", evicted)
	}
}

// æµ‹è¯•Remove(key)
func TestRemove(t *testing.T) {
	lru := New(int64(0), nil)

	lru.Add("key1", String("111"))
	lru.Add("key2", String("222"))

	lru.Remove("key1")

	if _, ok := lru.Get("key1"); ok {
		t.Fatalf("expected a to be removed")
	}

	if lru.Len() != 1 {
		t.Fatalf("expected cache len = 1, got %d", lru.Len())
	}
}

// Get åº”ç§»åŠ¨å…ƒç´ åˆ°é˜Ÿå¤´ï¼Œç¡®ä¿ LRU çš„æœ€æ—§å…ƒç´ æ­£ç¡®è¢«æ·˜æ±°
func TestGetMoveToFront(t *testing.T) {
	lru := New(int64(1000), nil)

	lru.Add("a", String("1"))
	lru.Add("b", String("2"))
	lru.Add("c", String("3"))

	// è®¿é—® a -> a å˜æˆæœ€æ–°ä½¿ç”¨
	lru.Get("a")

	// ä¸‹ä¸€æ¬¡æ’å…¥å¯¼è‡´ b è¢«æ·˜æ±°ï¼ˆå› ä¸ºbæˆä¸ºæœ€ä¹…æœªä½¿ç”¨ï¼‰
	// ä¿è¯åªèƒ½å®¹çº³ b,c æˆ– a,c
	lru.maxBytes = int64(len("b") + len("2") + len("c") + len("3"))

	lru.Add("d", String("4")) // ä¼šæ·˜æ±° b

	if _, ok := lru.Get("b"); ok {
		t.Fatalf("expected b to be evicted")
	}
}

// æµ‹è¯• nbytes ç´¯åŠ /å‡å°‘æ˜¯å¦æ­£ç¡®
func TestNbytes(t *testing.T) {
	lru := New(0, nil)

	lru.Add("key1", String("111"))
	expected := int64(len("key1") + len("111"))
	if lru.nbytes != expected {
		t.Fatalf("nbytes incorrect, want %d got %d", expected, lru.nbytes)
	}

	// åˆ é™¤key1
	lru.Remove("key1")
	if lru.nbytes != 0 {
		t.Fatalf("nbytes should be 0 after removal, got %d", lru.nbytes)
	}
}
</file>

<file path="internal/group/group_test.go">
package group

import (
	pb "DistributedCache/api/cachepb"
	"fmt"
	"reflect"
	"sync"
	"testing"
	"time"
)

// æ¨¡æ‹Ÿæ•°æ®åº“æ•°æ®
var db = map[string]string{
	"Tom":  "600",
	"jack": "598",
	"Sam":  "673",
}

// TestGetter æµ‹è¯• GetterFunc æ¥å£è½¬æ¢æ˜¯å¦æ­£å¸¸
func TestGetter(t *testing.T) {
	// å£°æ˜ä¸€ä¸ªç±»å‹ä¸ºGetterçš„å˜é‡f
	// GetterFunc(...)ï¼šGetterFuncæ˜¯å®ç°Getteræ¥å£çš„ç±»å‹
	// å®ƒæ¥å—ä¸€ä¸ªåŒ¿åå‡½æ•°ä½œä¸ºå‚æ•°
	var f Getter = GetterFunc(func(key string) ([]byte, error) {
		return []byte(key), nil
	})

	// reflect.DeepEqualå¯ä»¥æ¯”è¾ƒå‡ ä¹æ‰€æœ‰ç±»å‹
	expect := []byte("key")
	if v, _ := f.Get("key"); !reflect.DeepEqual(v, expect) {
		t.Errorf("callback failed")
	}
}

// æµ‹è¯•æœ¬åœ°ç¼“å­˜è·å–æµç¨‹ï¼ˆç¼“å­˜æœªå‘½ä¸­ -> å›æº -> ç¼“å­˜å‘½ä¸­ï¼‰
func TestGet(t *testing.T) {
	loadCounts := make(map[string]int, len(db))

	// åˆ›å»º Groupï¼Œå®šä¹‰å›æºé€»è¾‘
	gee := NewGroup("scores", 2<<10, "lru", GetterFunc(
		func(key string) ([]byte, error) {
			// è®°å½•å›æºæ¬¡æ•°
			loadCounts[key]++
			if v, ok := db[key]; ok {
				return []byte(v), nil
			}
			return nil, fmt.Errorf("%s not exist", key)
		}))

	// 1. éå†æµ‹è¯•æ•°æ®ï¼Œç¬¬ä¸€æ¬¡è·å–åº”è§¦å‘å›æº
	for k, v := range db {
		view, err := gee.Get(k)
		if err != nil {
			t.Fatal(err)
		}
		// å‡è®¾ ByteView æœ‰ String() æ–¹æ³•ï¼Œå¦‚æœæ²¡æœ‰è¯·ä½¿ç”¨ string(view.ByteSlice())
		if view.String() != v {
			t.Errorf("option %s, expected %s, got %s", k, v, view.String())
		}

		// éªŒè¯å›æºæ¬¡æ•°ä¸º 1
		if loadCounts[k] > 1 {
			t.Fatalf("cache %s miss", k)
		}
	}

	// 2. å†æ¬¡è·å–ï¼Œåº”è¯¥ç›´æ¥å‘½ä¸­ç¼“å­˜ï¼ŒloadCounts ä¸åº”å¢åŠ 
	for k := range db {
		_, err := gee.Get(k)
		if err != nil {
			t.Fatal(err)
		}
		if loadCounts[k] > 1 {
			t.Fatalf("cache %s miss", k)
		}
	}

	// 3. æµ‹è¯•ä¸å­˜åœ¨çš„ key
	if view, err := gee.Get("unknown"); err == nil {
		t.Fatalf("the value of unknown should be empty, but %s got", view)
	}
}

// TestGetGroup æµ‹è¯• Group çš„æ³¨å†Œä¸è·å–
func TestGetGroup(t *testing.T) {
	gName := "scores_group_test"
	NewGroup(gName, 2<<10, "lru", GetterFunc(
		func(key string) ([]byte, error) { return nil, nil }))

	if group := GetGroup(gName); group == nil || group.name != gName {
		t.Fatalf("group %s not exist", gName)
	}

	if group := GetGroup("scores_not_exist"); group != nil {
		t.Fatalf("expect nil, but %v got", group)
	}
}

// TestSingleflight æµ‹è¯•å¹¶å‘é˜²å‡»ç©¿æœºåˆ¶
func TestSingleflight(t *testing.T) {
	var loadCount int
	var mu sync.Mutex

	// åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿè€—æ—¶çš„ Group
	g := NewGroup("flight_test", 2<<10, "lru", GetterFunc(
		func(key string) ([]byte, error) {
			mu.Lock()
			loadCount++ // è®°å½•è¿™ä¸ªå‡½æ•°è¢«è°ƒç”¨äº†å¤šå°‘æ¬¡
			mu.Unlock()
			time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿæ…¢æŸ¥è¯¢
			return []byte("bar"), nil
		}))

	var wg sync.WaitGroup
	// å‘èµ· 10 ä¸ªå¹¶å‘è¯·æ±‚
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			view, err := g.Get("foo") // æ‰€æœ‰ goroutine éƒ½è¯·æ±‚ç›¸åŒçš„ key: "foo"
			if err != nil {
				t.Errorf("Get error: %v", err)
			}
			if view.String() != "bar" {
				t.Errorf("expect bar, got %s", view.String())
			}
		}()
	}
	wg.Wait() // ç­‰å¾…æ‰€æœ‰ 10 ä¸ª goroutine å®Œæˆ

	// éªŒè¯å›æºé€»è¾‘åªæ‰§è¡Œäº†ä¸€æ¬¡
	if loadCount != 1 {
		t.Errorf("expect 1 call,got %d", loadCount)
	}
}

// --- Mock å¯¹è±¡ç”¨äºæµ‹è¯•è¿œç¨‹èŠ‚ç‚¹è·å–é€»è¾‘ ---

// mockPeerGetter æ¨¡æ‹Ÿè¿œç¨‹èŠ‚ç‚¹å®¢æˆ·ç«¯
type mockPeerGetter struct {
	data map[string][]byte // è¿œç¨‹èŠ‚ç‚¹å­˜å‚¨çš„æ•°æ®
}

func (m *mockPeerGetter) Get(in *pb.GetRequest, out *pb.GetResponse) error {
	// æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚ï¼šæ ¹æ® key è¿”å›æ•°æ®
	if v, ok := m.data[in.Key]; ok {
		out.Value = v
		return nil
	}
	return fmt.Errorf("remote key not found")
}

// mockPeerPicker æ¨¡æ‹ŸèŠ‚ç‚¹é€‰æ‹©å™¨
type mockPeerPicker struct {
	peers map[string]*mockPeerGetter // èŠ‚ç‚¹åœ°å€->è¿œç¨‹å®¢æˆ·ç«¯
}

func (m *mockPeerPicker) PickPeer(key string) (PeerGetter, bool) {
	// æ¨¡æ‹Ÿé€»è¾‘ï¼šå¦‚æœ key æ˜¯ "remote_key"ï¼Œåˆ™è¿”å› mock èŠ‚ç‚¹
	if key == "remote_key" && len(m.peers) > 0 {
		for _, p := range m.peers {
			return p, true
		}
	}
	return nil, false
}

// TestGetFromPeer æµ‹è¯•ä»è¿œç¨‹èŠ‚ç‚¹è·å–æ•°æ®
func TestGetFromPeer(t *testing.T) {
	// 1. å‡†å¤‡è¿œç¨‹èŠ‚ç‚¹æ•°æ®
	remoteVal := []byte("remote_value_123")
	peer := &mockPeerGetter{
		data: map[string][]byte{
			"remote_key": remoteVal,
		},
	}

	// 2.å‡†å¤‡ PeerPicker
	picker := &mockPeerPicker{
		peers: map[string]*mockPeerGetter{
			"peer1": peer,
		},
	}

	// 3.åˆ›å»º Group
	g := NewGroup("remote_test", 2<<10, "lru", GetterFunc(
		func(key string) ([]byte, error) {
			return nil, fmt.Errorf("should not be called for remote hit")
		}))

	// æ³¨å†ŒèŠ‚ç‚¹é€‰æ‹©å™¨
	g.RegisterPeers(picker)

	// 4. æ‰§è¡ŒGetï¼Œé¢„æœŸå‘½ä¸­è¿œç¨‹èŠ‚ç‚¹
	view, err := g.Get("remote_key")
	if err != nil {
		t.Fatalf("failed to get from peer: %v", err)
	}

	if !reflect.DeepEqual(view.ByteSlice(), remoteVal) {
		t.Errorf("expect %s, got %s", string(remoteVal), view.String())
	}

	// 5. éªŒè¯æ˜¯å¦å·²å†™å…¥æœ¬åœ°ç¼“å­˜ ï¼ˆå†æ¬¡è·å–ä¸åº”æŠ¥é”™ï¼Œä¹Ÿä¸åº”èµ°è¿œç¨‹ - è™½ç„¶ Mock æ²¡è®¡æ•°ï¼Œä½†å¯ä»¥éªŒè¯å€¼å­˜åœ¨ï¼‰
	view2, err := g.Get("remote_key")
	if err != nil {
		t.Fatalf("failed to get from local cache after remote fetch: %v", err)
	}
	if view2.String() != string(remoteVal) {
		t.Errorf("expect %s, got %s", string(remoteVal), view2.String())
	}
}
</file>

<file path="internal/group/group.go">
package group

import (
	pb "DistributedCache/api/cachepb"
	"DistributedCache/internal/byteview"
	"DistributedCache/internal/cache"
	"DistributedCache/internal/singleflight"
	"fmt"
	"log"
	"sync"
)

// Getter å®šä¹‰äº†å½“ç¼“å­˜ä¸å­˜åœ¨æ—¶ï¼Œå¦‚ä½•ä»æ•°æ®æºï¼ˆDB/æ–‡ä»¶ï¼‰è·å–æ•°æ®çš„æ¥å£
type Getter interface {
	Get(key string) ([]byte, error)
}

// å®šä¹‰å‡½æ•°ç±»å‹ï¼Œå®ç°Getteræ¥å£
type GetterFunc func(key string) ([]byte, error)

// GetterFuncç±»å‹å®ç°Getteræ¥å£çš„Getæ–¹æ³•
func (f GetterFunc) Get(key string) ([]byte, error) {
	return f(key)
}

// Group æ˜¯åˆ†å¸ƒå¼ç¼“å­˜çš„æ ¸å¿ƒç»“æ„
type Group struct {
	name      string              //ç¼“å­˜ç©ºé—´åç§°ï¼Œä¾‹å¦‚ "scores", "users"
	getter    Getter              //ç¼“å­˜æœªå‘½ä¸­æ—¶çš„å›æºå›è°ƒ
	mainCache *cache.Cache        //æœ¬åœ°å¹¶å‘ç¼“å­˜ (å°è£…äº† LRU/LFU ç­‰)
	peers     PeerPicker          // èŠ‚ç‚¹é€‰æ‹©å™¨
	loader    *singleflight.Group // é˜²æ­¢ç¼“å­˜å‡»ç©¿
}

var (
	mu     sync.RWMutex
	groups = make(map[string]*Group)
)

// NewGroup åˆ›å»ºä¸€ä¸ªæ–°çš„ç¼“å­˜ç»„
// cacheBytesï¼š"ç¼“å­˜æœ€å¤§å­—èŠ‚æ•°
// policyTypeï¼š"lru","fifo","lfu"
func NewGroup(name string, cacheBytes int64, policyType string, getter Getter) *Group {
	if getter == nil {
		panic("nil Getter")
	}
	mu.Lock()
	defer mu.Unlock()
	g := &Group{
		name:      name,
		getter:    getter,
		mainCache: cache.NewCache(cacheBytes, policyType, nil),
		loader:    &singleflight.Group{},
	}
	groups[name] = g
	return g
}

// GetGroup è¿”å›æŒ‡å®šåç§°çš„Group
func GetGroup(name string) *Group {
	mu.RLock()
	g := groups[name]
	mu.RUnlock()
	return g
}

// RegisterPeers æ³¨å†ŒèŠ‚ç‚¹é€‰æ‹©å™¨
// è¿™å°†å…è®¸ Group é€‰æ‹©è¿œç¨‹èŠ‚ç‚¹
func (g *Group) RegisterPeers(peers PeerPicker) {
	if g.peers != nil {
		panic("RegisterPeers called more than once")
	}
	g.peers = peers
}

// Getè·å–ç¼“å­˜å€¼
// æµç¨‹ï¼šæœ¬åœ°ç¼“å­˜ -> (å¦‚æœæ²¡å‘½ä¸­) -> é€‰èŠ‚ç‚¹ -> (å¦‚æœæ˜¯è¿œç¨‹) RPCè·å– -> (å¦‚æœæ˜¯æœ¬åœ°) å›æºè·å–
func (g *Group) Get(key string) (byteview.Byteview, error) {
	if key == "" {
		return byteview.Byteview{}, fmt.Errorf("key is required")
	}

	// 1.æŸ¥æœ¬åœ°ç¼“å­˜
	if v, ok := g.mainCache.Get(key); ok {
		log.Println("[Cache] Hit local")
		return v, nil
	}

	// 2.ç¼“å­˜æœªå‘½ä¸­ï¼Œè°ƒç”¨loadï¼ˆåŒ…å«è¿œç¨‹åŠ è½½å’Œæœ¬åœ°å›æºï¼‰
	return g.load(key)
}

// load åŠ è½½æ•°æ®ï¼Œä½¿ç”¨ singleflight ç¡®ä¿å¹¶å‘åœºæ™¯ä¸‹åªæœ‰ä¸€ä¸ªè¯·æ±‚å»åŠ è½½
func (g *Group) load(key string) (value byteview.Byteview, err error) {
	// ä½¿ç”¨ singleflight åŒ…è£…
	viewi, err := g.loader.Do(key, func() (interface{}, error) {
		// å†…éƒ¨åŠ è½½é€»è¾‘
		if g.peers != nil {
			// ä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œé€‰æ‹©èŠ‚ç‚¹
			if peer, ok := g.peers.PickPeer(key); ok {
				// å¦‚æœé€‰ä¸­çš„ä¸æ˜¯è‡ªå·±ï¼Œå°è¯•ä»è¿œç¨‹è·å–
				if value, err = g.getFromPeer(peer, key); err == nil {
					return value, nil
				}
				log.Println("[Cache] Failed to get from peer", err)
			}
		}
		// å¦‚æœæ²¡æœ‰è¿œç¨‹èŠ‚ç‚¹ï¼Œæˆ–è€…é€‰ä¸­çš„æ˜¯è‡ªå·±ï¼Œè·å–è¿œç¨‹è·å–å¤±è´¥ï¼Œåˆ™å›æº
		return g.getLocally(key)
	})

	if err == nil {
		return viewi.(byteview.Byteview), nil
	}
	return
}

// getLocally è°ƒç”¨ç”¨æˆ·å›è°ƒå‡½æ•°g.getter.Get()è·å–æºæ•°æ®
func (g *Group) getLocally(key string) (byteview.Byteview, error) {
	bytes, err := g.getter.Get(key)
	if err != nil {
		return byteview.Byteview{}, err
	}
	value := byteview.New(bytes)

	// å°†æºæ•°æ®å¡«å……åˆ°æœ¬åœ°ç¼“å­˜
	g.populateCache(key, value)
	return value, nil
}

// getFromPeer é€šè¿‡ RPC è®¿é—®è¿œç¨‹èŠ‚ç‚¹
func (g *Group) getFromPeer(peer PeerGetter, key string) (byteview.Byteview, error) {
	// 1. å‡†å¤‡è¯·æ±‚ï¼šå‘Šè¯‰è¿œç¨‹èŠ‚ç‚¹æˆ‘è¦ä»€ä¹ˆ
	req := &pb.GetRequest{
		Group: g.name, // ç¼“å­˜ç©ºé—´
		Key:   key,    // å…·ä½“key
	}
	// 2. è¿œç¨‹è°ƒç”¨
	res := &pb.GetResponse{}
	err := peer.Get(req, res) // ç½‘ç»œè¯·æ±‚ï¼
	if err != nil {
		return byteview.Byteview{}, err
	}

	// è¿œç¨‹è·å–çš„æ•°æ®
	value := byteview.New(res.Value)
	// ã€å…³é”®ç‚¹ - çƒ­ç‚¹äº’å¤‡ã€‘
	// å¦‚æœè¿™é‡Œæˆ‘ä»¬æŠŠè¿œç¨‹è·å–åˆ°çš„æ•°æ®å†™å…¥æœ¬åœ°ç¼“å­˜ï¼š
	// ä¼˜ç‚¹ï¼šä¸‹æ¬¡è¯·æ±‚ç›´æ¥å‘½ä¸­æœ¬åœ°ï¼Œä¸å†èµ°ç½‘ç»œï¼Œæå¤§ç¼“è§£çƒ­ç‚¹ Key å¯¹ Owner èŠ‚ç‚¹çš„å†²å‡»ã€‚
	// ç¼ºç‚¹ï¼šæ•°æ®ä¸€è‡´æ€§ç¨å·®ï¼Œå ç”¨æœ¬åœ°å†…å­˜ã€‚
	g.populateCache(key, value)
	return value, nil
}

// populateCache å°†æ•°æ®æ·»åŠ åˆ°æœ¬åœ°ç¼“å­˜
func (g *Group) populateCache(key string, value byteview.Byteview) {
	g.mainCache.Add(key, value)
}
</file>

<file path="go.mod">
module DistributedCache

go 1.24.9

require (
	go.etcd.io/etcd/client/v3 v3.6.7
	google.golang.org/grpc v1.77.0
	google.golang.org/protobuf v1.36.11
)

require (
	github.com/coreos/go-semver v0.3.1 // indirect
	github.com/coreos/go-systemd/v22 v22.5.0 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang/protobuf v1.5.4 // indirect
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.26.3 // indirect
	go.etcd.io/etcd/api/v3 v3.6.7 // indirect
	go.etcd.io/etcd/client/pkg/v3 v3.6.7 // indirect
	go.uber.org/multierr v1.11.0 // indirect
	go.uber.org/zap v1.27.0 // indirect
	golang.org/x/net v0.46.1-0.20251013234738-63d1a5100f82 // indirect
	golang.org/x/sys v0.37.0 // indirect
	golang.org/x/text v0.30.0 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20251022142026-3a174f9686a8 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20251022142026-3a174f9686a8 // indirect
)
</file>

</files>
